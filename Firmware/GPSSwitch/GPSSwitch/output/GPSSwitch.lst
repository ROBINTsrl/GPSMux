FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C271xx members of the 27xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0117)     ;---------------------------------------------------
                                        (0118)     ; Insert your custom code below this banner
                                        (0119)     ;---------------------------------------------------
                                        (0120) 
                                        (0121)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0122)     halt                           ;Stop execution if power falls too low
                                        (0123) 
                                        (0124)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0125)     // call	void_handler
0008: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0129)     // call	void_handler
000C: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0133)     // call	void_handler
0010: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0137)     // call	void_handler
0014: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   18h                      ;VC3 Interrupt Vector
                                        (0141)     // call	void_handler
0018: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0145)     // call	void_handler
001C: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0149)     // call	void_handler
0020: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0153)     // call	void_handler
0024: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 03 01 LJMP  _TX8_ISR           (0157)     ljmp	_TX8_ISR
002B: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                        (0161)     // call	void_handler
002C: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                        (0165)     // call	void_handler
0030: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                        (0169)     // call	void_handler
0034: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
0038: 7D 03 B4 LJMP  _TX8_PutCRLF|_RX8_2_ISR(0173)     ljmp	_RX8_2_ISR
003B: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
003C: 7D 04 2B LJMP  _RX8_2_iReadChar|_RX8_2_cReadChar|_RX8_1_ISR(0177)     ljmp	_RX8_1_ISR
003F: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0181)     // call	void_handler
0060: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0185)     // call	void_handler
0064: 7E       RETI                     (0186)     reti
0068: 71 10    OR    F,0x10             
                                        (0187)     ;---------------------------------------------------
                                        (0188)     ; Insert your custom code above this banner
                                        (0189)     ;---------------------------------------------------
                                        (0190)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0191) 
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;  Start of Execution.
                                        (0194) ;-----------------------------------------------------------------------------
                                        (0195) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0196) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0197) ;
                                        (0198) 
                                        (0199) IF	(TOOLCHAIN & HITECH)
                                        (0200)  	AREA PD_startup(CODE, REL, CON)
                                        (0201) ELSE
                                        (0202)     org 68h
                                        (0203) ENDIF
                                        (0204) __Start:
                                        (0205) 
                                        (0206)     ; Initialize the voltage monitoring values,
                                        (0207)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0208)     ; least for now. 
                                        (0209)     ;
                                        (0210)     M8C_SetBank1
006A: 62 E3 82 MOV   REG[0xE3],0x82     (0211)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
0072: 41 FF EF AND   REG[0xFF],0xEF     
                                        (0212)     M8C_SetBank0
                                        (0213) 
                                        (0214) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0215) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0216)     M8C_EnableWatchDog
                                        (0217) ENDIF
                                        (0218) 
                                        (0219) IF ( SELECT_32K )
                                        (0220)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0221) ELSE
0075: 41 FE FB AND   REG[0xFE],0xFB     (0222)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0223) ENDIF
                                        (0224) 
                                        (0225) IF	(TOOLCHAIN & HITECH)
                                        (0226)     ;---------------------------
                                        (0227)     ; Set up the Temporary stack
                                        (0228)     ;---------------------------
                                        (0229)     ; A temporary stack is set up for the SSC instructions.
                                        (0230)     ; The real stack start will be assigned later.
                                        (0231)     ;
                                        (0232) 	global		__Lstackps
                                        (0233) 	mov     a,low __Lstackps
                                        (0234) 	swap    a,sp
                                        (0235) ELSE
                                        (0236)     ;------------------
                                        (0237)     ; Set up the stack
                                        (0238)     ;------------------
0078: 50 5E    MOV   A,0x5E             (0239)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
007A: 4E       SWAP  SP,A               (0240)     swap  SP, A                    ; This is only temporary if going to LMM
007B: 62 E3 38 MOV   REG[0xE3],0x38     
007E: 55 FA 01 MOV   [_ramareas_end+156],0x1
0081: 4F       MOV   X,SP               
0082: 5B       MOV   A,X                
0083: 01 03    ADD   A,0x3              
0085: 53 F9    MOV   [_ramareas_end+155],A
0087: 55 F8 3A MOV   [_ramareas_end+154],0x3A
008A: 50 06    MOV   A,0x6              
008C: 00       SWI                      
008D: 71 10    OR    F,0x10             
008F: 51 F9    MOV   A,[_ramareas_end+155]
0091: 60 E8    MOV   REG[0xE8],A        
0093: 51 F8    MOV   A,[_ramareas_end+154]
0095: 60 EA    MOV   REG[0xEA],A        
0097: 70 EF    AND   F,0xEF             
                                        (0241) ENDIF
                                        (0242) 
                                        (0243)     ;-----------------------------------------------
                                        (0244)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0245)     ;-----------------------------------------------
                                        (0246) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0247) IF ( SUPPLY_VOLTAGE )         ; 1 means 5.0V
                                        (0248)  IF ( AGND_BYPASS )
                                        (0249)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0250)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0251)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0252)     ; value using the proper trim values.
                                        (0253)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0254)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0255)  ENDIF
                                        (0256) ELSE    ; 3.3 V Operation, not 5.0V
                                        (0257)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0258) ENDIF ;(SUPPLY_VOLTAGE)
                                        (0259) 
0099: 55 F8 00 MOV   [_ramareas_end+154],0x0(0260)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
009C: 55 F9 00 MOV   [_ramareas_end+155],0x0(0261)     mov  [bSSC_KEYSP], 0
009F: 71 10    OR    F,0x10             
                                        (0262) 
                                        (0263)     ;---------------------------------------
                                        (0264)     ; Initialize Crystal Oscillator and PLL
                                        (0265)     ;---------------------------------------
                                        (0266) 
                                        (0267) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0268)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0269)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0270)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0271)     ; the ECO to stabilize.
                                        (0272)     ;
                                        (0273)     M8C_SetBank1
                                        (0274)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0275)     M8C_SetBank0
                                        (0276)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0277)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0278)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0279) .WaitFor1s:
                                        (0280)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0281)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0282)                                           ;   since interrupts are not globally enabled
                                        (0283) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0284)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0285)     M8C_SetBank1
00A1: 62 E0 1A MOV   REG[0xE0],0x1A     (0286)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00A4: 70 EF    AND   F,0xEF             
00A6: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0287)     M8C_SetBank0
                                        (0288)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0289) 
                                        (0290) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0291) 
                                        (0292) IF ( PLL_MODE )
                                        (0293)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0294)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0295)     ;
                                        (0296)     M8C_SetBank1
                                        (0297)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0298)     M8C_SetBank0
                                        (0299)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0300)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0301) 
                                        (0302) .WaitFor16ms:
                                        (0303)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0304)     jz   .WaitFor16ms
                                        (0305)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0306)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0307)     M8C_SetBank0
                                        (0308) 
                                        (0309) IF      ( WAIT_FOR_32K )
                                        (0310) ELSE ; !( WAIT_FOR_32K )
                                        (0311)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0312)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0313) ENDIF ;(WAIT_FOR_32K)
                                        (0314) ENDIF ;(PLL_MODE)
                                        (0315) 
                                        (0316) 	;-------------------------------------------------------
                                        (0317)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0318)     ;-------------------------------------------------------
                                        (0319) 
                                        (0320)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0321) 
                                        (0322) IF (SYSCLK_SOURCE)
                                        (0323)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0324) ENDIF
                                        (0325)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0326) 
                                        (0327)     ;------------------------
                                        (0328)     ; Close CT leakage path.
                                        (0329)     ;------------------------
00A9: 62 71 05 MOV   REG[0x71],0x5      (0330)     mov   reg[ACB00CR0], 05h
00AC: 62 75 05 MOV   REG[0x75],0x5      (0331)     mov   reg[ACB01CR0], 05h
00AF: 62 79 05 MOV   REG[0x79],0x5      (0332)     mov   reg[ACB02CR0], 05h
00B2: 62 7D 05 MOV   REG[0x7D],0x5      (0333)     mov   reg[ACB03CR0], 05h
                                        (0334) 
                                        (0335)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0336)     ;---------------------------------------------------
                                        (0337)     ; Insert your custom code below this banner
                                        (0338)     ;---------------------------------------------------
                                        (0339) 
                                        (0340)     ;---------------------------------------------------
                                        (0341)     ; Insert your custom code above this banner
                                        (0342)     ;---------------------------------------------------
                                        (0343)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0344) 
                                        (0345)     ;-------------------------
                                        (0346)     ; Load Base Configuration
                                        (0347)     ;-------------------------
                                        (0348)     ; Load global parameter settings and load the user modules in the
                                        (0349)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0350)     ; to minimize start up time; (2) We may still need to play with the
                                        (0351)     ; Sleep Timer.
                                        (0352)     ;
00B5: 7C 02 A0 LCALL 0x02A0             (0353)     lcall LoadConfigInit
                                        (0354) 
                                        (0355)     ;-----------------------------------
                                        (0356)     ; Initialize C Run-Time Environment
                                        (0357)     ;-----------------------------------
                                        (0358) IF ( C_LANGUAGE_SUPPORT )
00B8: 50 00    MOV   A,0x0              (0359)     mov  A,0                           ; clear the 'bss' segment to zero
00BA: 55 15 17 MOV   [__r0],0x17        (0360)     mov  [__r0],<__bss_start
                                        (0361) BssLoop:
00BD: 3C 15 5E CMP   [__r0],0x5E        (0362)     cmp  [__r0],<__bss_end
00C0: A0 05    JZ    0x00C6             (0363)     jz   BssDone
00C2: 3F 15    MVI   [__r0],A           (0364)     mvi  [__r0],A
00C4: 8F F8    JMP   0x00BD             (0365)     jmp  BssLoop
                                        (0366) BssDone:
00C6: 50 01    MOV   A,0x1              (0367)     mov  A,>__idata_start              ; copy idata to data segment
00C8: 57 D4    MOV   X,0xD4             (0368)     mov  X,<__idata_start
00CA: 55 15 00 MOV   [__r0],0x0         (0369)     mov  [__r0],<__data_start
                                        (0370) IDataLoop:
00CD: 3C 15 07 CMP   [__r0],0x7         (0371)     cmp  [__r0],<__data_end
00D0: A0 0B    JZ    0x00DC             (0372)     jz   C_RTE_Done
00D2: 08       PUSH  A                  (0373)     push A
00D3: 28       ROMX                     (0374)     romx
00D4: 3F 15    MVI   [__r0],A           (0375)     mvi  [__r0],A
00D6: 18       POP   A                  (0376)     pop  A
00D7: 75       INC   X                  (0377)     inc  X
00D8: 09 00    ADC   A,0x0              (0378)     adc  A,0
00DA: 8F F2    JMP   0x00CD             (0379)     jmp  IDataLoop
00DC: 71 10    OR    F,0x10             
00DE: 70 EF    AND   F,0xEF             
                                        (0380) 
                                        (0381) C_RTE_Done:
                                        (0382) 
                                        (0383) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0384) 
                                        (0385)     ;-------------------------------
                                        (0386)     ; Set Power-On Reset (POR) Level
                                        (0387)     ;-------------------------------
                                        (0388)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH, 
                                        (0389)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper 
                                        (0390)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0391)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0392)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0393) 
                                        (0394)     M8C_SetBank1
                                        (0395) 
                                        (0396) IF ( SUPPLY_VOLTAGE )                       ; 1 Means 5 Volts
                                        (0397)  IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )  ;    Also 24MHz?
                                        (0398)                                             ;       no, set 4.5V POR in user code, if desired
                                        (0399)  ELSE ; 24HMz                               ;
                                        (0400)     or    reg[VLT_CR],  VLT_CR_4V75_POR     ;       yes, 4.75V trip required
                                        (0401)  ENDIF ; OSC_CRO_CPU_24MHz
                                        (0402) ENDIF ; 5V
                                        (0403) 
                                        (0404)     M8C_SetBank0
                                        (0405) 
                                        (0406)     ;----------------------------
                                        (0407)     ; Wrap up and invoke "main"
                                        (0408)     ;----------------------------
                                        (0409) 
                                        (0410)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0411)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0412)     ;
00E0: 62 E0 00 MOV   REG[0xE0],0x0      (0413)     mov  reg[INT_MSK0],0
00E3: 71 10    OR    F,0x10             
                                        (0414) 
                                        (0415)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0416)     ;
                                        (0417)     M8C_SetBank1
00E5: 62 E0 1A MOV   REG[0xE0],0x1A     (0418)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
00E8: 70 EF    AND   F,0xEF             
                                        (0419)     M8C_SetBank0
                                        (0420) 
                                        (0421)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0422)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0423)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0424)     ;
00EA: 62 E2 00 MOV   REG[0xE2],0x0      (0425)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0426) IF	(TOOLCHAIN & HITECH)
                                        (0427) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0428) ELSE
                                        (0429)                                    ; have been set during the boot process.
                                        (0430) IF ENABLE_LJMP_TO_MAIN
                                        (0431)     ljmp  _main                    ; goto main (no return)
                                        (0432) ELSE
00ED: 7C 06 1E LCALL _main              (0433)     lcall _main                    ; call main
                                        (0434) .Exit:
00F0: 8F FF    JMP   0x00F0             (0435)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0436) ENDIF
                                        (0437) ENDIF ; TOOLCHAIN
                                        (0438) 
                                        (0439)     ;---------------------------------
                                        (0440)     ; Library Access to Global Parms
                                        (0441)     ;---------------------------------
                                        (0442)     ;
                                        (0443)  bGetPowerSetting:
                                        (0444) _bGetPowerSetting:
                                        (0445)     ; Synthesize the "power setting" value used by chips with SlowIMO mode.
                                        (0446)     ; Returns value of POWER_SETTING in the A register.
                                        (0447)     ; No inputs. No Side Effects.
                                        (0448)     ;
                                        (0449) IF ( SUPPLY_VOLTAGE )            ; 1 means 5.0V
                                        (0450)     mov   A, POWER_SET_5V0_24MHZ   ; Supply & Internal Main Oscillator speed
                                        (0451) ELSE        
00F2: 50 08    MOV   A,0x8              (0452)     mov   A, POWER_SET_3V3_24MHZ   ; Supply & Internal Main Oscillator speed
                                        (0453) ENDIF
00F4: 7F       RET                      (0454)     ret
                                        (0455) 
                                        (0456) IF	(TOOLCHAIN & HITECH)
                                        (0457) ELSE
                                        (0458)     ;---------------------------------
                                        (0459)     ; Order Critical RAM & ROM AREAs
                                        (0460)     ;---------------------------------
                                        (0461)     ;  'TOP' is all that has been defined so far...
                                        (0462) 
                                        (0463)     ;  ROM AREAs for C CONST, static & global items
                                        (0464)     ;
                                        (0465)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0466)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0467) __idata_start:
                                        (0468) 
                                        (0469)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0470) __func_lit_start:
                                        (0471) 
                                        (0472)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0473)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0474) 
                                        (0475)     ; CODE segment for general use
                                        (0476)     ;
                                        (0477)     AREA text (ROM, REL, CON)
                                        (0478) __text_start:
                                        (0479) 
                                        (0480)     ; RAM area usage
                                        (0481)     ;
                                        (0482)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0483) __data_start:
                                        (0484) 
                                        (0485)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0486)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0487)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0488) __bss_start:
                                        (0489) 
                                        (0490) ENDIF ; TOOLCHAIN
                                        (0491) 
                                        (0492) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.3191
01DB: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_gpsswitch_Bank1
                                        (0019) export LoadConfigTBL_gpsswitch_Bank0
                                        (0020) export LoadConfigTBL_gpsswitch_Ordered
                                        (0021) AREA lit(rom, rel)
                                        (0022) LoadConfigTBL_gpsswitch_Bank0:
                                        (0023) ;  Instance name LED_FIX, User Module LED
                                        (0024) ;  Instance name RX8_1, User Module RX8
                                        (0025) ;       Instance name RX8_1, Block Name RX8(DCB13)
                                        (0026) 	db		3fh, 00h		;RX8_1_CONTROL_REG  (DCB13CR0)
                                        (0027) 	db		3dh, 00h		;RX8_1_(DCB13DR1)
                                        (0028) 	db		3eh, 00h		;RX8_1_RX_BUFFER_REG(DCB13DR2)
                                        (0029) ;  Instance name RX8_2, User Module RX8
                                        (0030) ;       Instance name RX8_2, Block Name RX8(DCB12)
                                        (0031) 	db		3bh, 00h		;RX8_2_CONTROL_REG  (DCB12CR0)
                                        (0032) 	db		39h, 00h		;RX8_2_(DCB12DR1)
                                        (0033) 	db		3ah, 00h		;RX8_2_RX_BUFFER_REG(DCB12DR2)
                                        (0034) ;  Instance name TX8, User Module TX8
                                        (0035) ;       Instance name TX8, Block Name TX8(DCB02)
                                        (0036) 	db		2bh, 00h		;TX8_CONTROL_REG  (DCB02CR0)
                                        (0037) 	db		29h, 00h		;TX8_TX_BUFFER_REG(DCB02DR1)
                                        (0038) 	db		2ah, 00h		;TX8_(DCB02DR2)
                                        (0039) ;  Global Register values Bank 0
                                        (0040) 	db		60h, 69h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0041) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0042) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                        (0043) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0044) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0045) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0046) 	db		d6h, 00h		; I2CConfig register (I2CCFG)
                                        (0047) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0048) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0049) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0050) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0051) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0052) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0053) 	db		b6h, 01h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0054) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0055) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0056) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0057) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0058) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0059) 	db		bdh, 00h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0060) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0061) 	db		ffh
                                        (0062) LoadConfigTBL_gpsswitch_Bank1:
                                        (0063) ;  Instance name LED_FIX, User Module LED
                                        (0064) ;  Instance name RX8_1, User Module RX8
                                        (0065) ;       Instance name RX8_1, Block Name RX8(DCB13)
                                        (0066) 	db		3ch, 05h		;RX8_1_FUNC_REG     (DCB13FN)
                                        (0067) 	db		3dh, c1h		;RX8_1_INPUT_REG    (DCB13IN)
                                        (0068) 	db		3eh, 40h		;RX8_1_OUTPUT_REG   (DCB13OU)
                                        (0069) ;  Instance name RX8_2, User Module RX8
                                        (0070) ;       Instance name RX8_2, Block Name RX8(DCB12)
                                        (0071) 	db		38h, 05h		;RX8_2_FUNC_REG     (DCB12FN)
                                        (0072) 	db		39h, d1h		;RX8_2_INPUT_REG    (DCB12IN)
                                        (0073) 	db		3ah, 40h		;RX8_2_OUTPUT_REG   (DCB12OU)
                                        (0074) ;  Instance name TX8, User Module TX8
                                        (0075) ;       Instance name TX8, Block Name TX8(DCB02)
                                        (0076) 	db		28h, 0dh		;TX8_FUNC_REG     (DCB02FN)
                                        (0077) 	db		29h, 01h		;TX8_INPUT_REG    (DCB02IN)
                                        (0078) 	db		2ah, 46h		;TX8_OUTPUT_REG   (DCB02OU)
                                        (0079) ;  Global Register values Bank 1
                                        (0080) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0081) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0082) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0083) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0084) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0085) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0086) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0087) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0088) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0089) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0090) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0091) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0092) 	db		e1h, 13h		; OscillatorControl_1 register (OSC_CR1)
                                        (0093) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0094) 	db		dfh, 9bh		; OscillatorControl_3 register (OSC_CR3)
                                        (0095) 	db		deh, 01h		; OscillatorControl_4 register (OSC_CR4)
                                        (0096) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0097) 	db		ffh
                                        (0098) AREA psoc_config(rom, rel)
                                        (0099) LoadConfigTBL_gpsswitch_Ordered:
                                        (0100) ;  Ordered Global Register values
                                        (0101) 	M8C_SetBank0
01DD: 62 00 00 MOV   REG[0x0],0x0       (0102) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
01E0: 71 10    OR    F,0x10             
                                        (0103) 	M8C_SetBank1
01E2: 62 00 0C MOV   REG[0x0],0xC       (0104) 	mov	reg[00h], 0ch		; Port_0_DriveMode_0 register (PRT0DM0)
01E5: 62 01 30 MOV   REG[0x1],0x30      (0105) 	mov	reg[01h], 30h		; Port_0_DriveMode_1 register (PRT0DM1)
01E8: 70 EF    AND   F,0xEF             
                                        (0106) 	M8C_SetBank0
01EA: 62 03 00 MOV   REG[0x3],0x0       (0107) 	mov	reg[03h], 00h		; Port_0_DriveMode_2 register (PRT0DM2)
01ED: 62 02 34 MOV   REG[0x2],0x34      (0108) 	mov	reg[02h], 34h		; Port_0_GlobalSelect register (PRT0GS)
01F0: 71 10    OR    F,0x10             
                                        (0109) 	M8C_SetBank1
01F2: 62 02 00 MOV   REG[0x2],0x0       (0110) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
01F5: 62 03 00 MOV   REG[0x3],0x0       (0111) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
01F8: 70 EF    AND   F,0xEF             
                                        (0112) 	M8C_SetBank0
01FA: 62 01 00 MOV   REG[0x1],0x0       (0113) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
01FD: 62 04 00 MOV   REG[0x4],0x0       (0114) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
0200: 71 10    OR    F,0x10             
                                        (0115) 	M8C_SetBank1
0202: 62 04 00 MOV   REG[0x4],0x0       (0116) 	mov	reg[04h], 00h		; Port_1_DriveMode_0 register (PRT1DM0)
0205: 62 05 03 MOV   REG[0x5],0x3       (0117) 	mov	reg[05h], 03h		; Port_1_DriveMode_1 register (PRT1DM1)
0208: 70 EF    AND   F,0xEF             
                                        (0118) 	M8C_SetBank0
020A: 62 07 03 MOV   REG[0x7],0x3       (0119) 	mov	reg[07h], 03h		; Port_1_DriveMode_2 register (PRT1DM2)
020D: 62 06 00 MOV   REG[0x6],0x0       (0120) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
0210: 71 10    OR    F,0x10             
                                        (0121) 	M8C_SetBank1
0212: 62 06 00 MOV   REG[0x6],0x0       (0122) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
0215: 62 07 00 MOV   REG[0x7],0x0       (0123) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
0218: 70 EF    AND   F,0xEF             
                                        (0124) 	M8C_SetBank0
021A: 62 05 00 MOV   REG[0x5],0x0       (0125) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
021D: 62 08 00 MOV   REG[0x8],0x0       (0126) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
0220: 71 10    OR    F,0x10             
                                        (0127) 	M8C_SetBank1
0222: 62 08 00 MOV   REG[0x8],0x0       (0128) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
0225: 62 09 00 MOV   REG[0x9],0x0       (0129) 	mov	reg[09h], 00h		; Port_2_DriveMode_1 register (PRT2DM1)
0228: 70 EF    AND   F,0xEF             
                                        (0130) 	M8C_SetBank0
022A: 62 0B 00 MOV   REG[0xB],0x0       (0131) 	mov	reg[0bh], 00h		; Port_2_DriveMode_2 register (PRT2DM2)
022D: 62 0A 00 MOV   REG[0xA],0x0       (0132) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
0230: 71 10    OR    F,0x10             
                                        (0133) 	M8C_SetBank1
0232: 62 0A 00 MOV   REG[0xA],0x0       (0134) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
0235: 62 0B 00 MOV   REG[0xB],0x0       (0135) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
0238: 70 EF    AND   F,0xEF             
                                        (0136) 	M8C_SetBank0
023A: 62 09 00 MOV   REG[0x9],0x0       (0137) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
023D: 62 0C 00 MOV   REG[0xC],0x0       (0138) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
0240: 71 10    OR    F,0x10             
                                        (0139) 	M8C_SetBank1
0242: 62 0C 00 MOV   REG[0xC],0x0       (0140) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
0245: 62 0D 00 MOV   REG[0xD],0x0       (0141) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
0248: 70 EF    AND   F,0xEF             
                                        (0142) 	M8C_SetBank0
024A: 62 0F 00 MOV   REG[0xF],0x0       (0143) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
024D: 62 0E 00 MOV   REG[0xE],0x0       (0144) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0250: 71 10    OR    F,0x10             
                                        (0145) 	M8C_SetBank1
0252: 62 0E 00 MOV   REG[0xE],0x0       (0146) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
0255: 62 0F 00 MOV   REG[0xF],0x0       (0147) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0258: 70 EF    AND   F,0xEF             
                                        (0148) 	M8C_SetBank0
025A: 62 0D 00 MOV   REG[0xD],0x0       (0149) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
025D: 62 10 00 MOV   REG[0x10],0x0      (0150) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
0260: 71 10    OR    F,0x10             
                                        (0151) 	M8C_SetBank1
0262: 62 10 00 MOV   REG[0x10],0x0      (0152) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0265: 62 11 00 MOV   REG[0x11],0x0      (0153) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
0268: 70 EF    AND   F,0xEF             
                                        (0154) 	M8C_SetBank0
026A: 62 13 00 MOV   REG[0x13],0x0      (0155) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
026D: 62 12 00 MOV   REG[0x12],0x0      (0156) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0270: 71 10    OR    F,0x10             
                                        (0157) 	M8C_SetBank1
0272: 62 12 00 MOV   REG[0x12],0x0      (0158) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0275: 62 13 00 MOV   REG[0x13],0x0      (0159) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0278: 70 EF    AND   F,0xEF             
                                        (0160) 	M8C_SetBank0
027A: 62 11 00 MOV   REG[0x11],0x0      (0161) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
027D: 62 14 00 MOV   REG[0x14],0x0      (0162) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
0280: 71 10    OR    F,0x10             
                                        (0163) 	M8C_SetBank1
0282: 62 14 00 MOV   REG[0x14],0x0      (0164) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0285: 62 15 00 MOV   REG[0x15],0x0      (0165) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0288: 70 EF    AND   F,0xEF             
                                        (0166) 	M8C_SetBank0
028A: 62 17 00 MOV   REG[0x17],0x0      (0167) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
028D: 62 16 00 MOV   REG[0x16],0x0      (0168) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0290: 71 10    OR    F,0x10             
                                        (0169) 	M8C_SetBank1
0292: 62 16 00 MOV   REG[0x16],0x0      (0170) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0295: 62 17 00 MOV   REG[0x17],0x0      (0171) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0298: 70 EF    AND   F,0xEF             
                                        (0172) 	M8C_SetBank0
029A: 62 15 00 MOV   REG[0x15],0x0      (0173) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
029D: 70 EF    AND   F,0xEF             
                                        (0174) 	M8C_SetBank0
029F: 7F       RET                      (0175) 	ret
                                        (0176) 
                                        (0177) 
                                        (0178) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_gpsswitch
                                        (0026) export _LoadConfig_gpsswitch
                                        (0027) export Port_0_Data_SHADE
                                        (0028) export _Port_0_Data_SHADE
                                        (0029) 
                                        (0030) 
                                        (0031) export NO_SHADOW
                                        (0032) export _NO_SHADOW
                                        (0033) 
                                        (0034) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0035) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0036) 
                                        (0037) AREA psoc_config(rom, rel)
                                        (0038) 
                                        (0039) ;---------------------------------------------------------------------------
                                        (0040) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0041) ;                  parameters handled by boot code, like CPU speed). This
                                        (0042) ;                  function can be called from user code, but typically it
                                        (0043) ;                  is only called from boot.
                                        (0044) ;
                                        (0045) ;       INPUTS: None.
                                        (0046) ;      RETURNS: Nothing.
                                        (0047) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0048) ;               In the large memory model currently only the page
                                        (0049) ;               pointer registers listed below are modified.  This does
                                        (0050) ;               not guarantee that in future implementations of this
                                        (0051) ;               function other page pointer registers will not be
                                        (0052) ;               modified.
                                        (0053) ;          
                                        (0054) ;               Page Pointer Registers Modified: 
                                        (0055) ;               CUR_PP
                                        (0056) ;
                                        (0057) _LoadConfigInit:
                                        (0058)  LoadConfigInit:
                                        (0059)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0060)     
02A0: 55 16 00 MOV   [0x16],0x0         (0061) 	mov		[Port_0_Data_SHADE], 0h
                                        (0062) 
02A3: 7C 02 AA LCALL 0x02AA             (0063) 	lcall	LoadConfig_gpsswitch
02A6: 7C 01 DB LCALL 0x01DB             (0064) 	lcall	LoadConfigTBL_gpsswitch_Ordered
                                        (0065) 
                                        (0066) 
                                        (0067)     RAM_EPILOGUE RAM_USE_CLASS_4
02A9: 7F       RET                      (0068)     ret
                                        (0069) 
                                        (0070) ;---------------------------------------------------------------------------
                                        (0071) ; Load Configuration gpsswitch
                                        (0072) ;
                                        (0073) ;    Load configuration registers for gpsswitch.
                                        (0074) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0075) ;
                                        (0076) ;       INPUTS: None.
                                        (0077) ;      RETURNS: Nothing.
                                        (0078) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0079) ;               modified as may the Page Pointer registers!
                                        (0080) ;               In the large memory model currently only the page
                                        (0081) ;               pointer registers listed below are modified.  This does
                                        (0082) ;               not guarantee that in future implementations of this
                                        (0083) ;               function other page pointer registers will not be
                                        (0084) ;               modified.
                                        (0085) ;          
                                        (0086) ;               Page Pointer Registers Modified: 
                                        (0087) ;               CUR_PP
                                        (0088) ;
                                        (0089) _LoadConfig_gpsswitch:
                                        (0090)  LoadConfig_gpsswitch:
                                        (0091)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0092) 
02AA: 10       PUSH  X                  (0093) 	push	x
02AB: 70 EF    AND   F,0xEF             
                                        (0094)     M8C_SetBank0                    ; Force bank 0
02AD: 50 00    MOV   A,0x0              (0095)     mov     a, 0                    ; Specify bank 0
02AF: 67       ASR   A                  (0096)     asr     a                       ; Store in carry flag
                                        (0097)                                     ; Load bank 0 table:
02B0: 50 01    MOV   A,0x1              (0098)     mov     A, >LoadConfigTBL_gpsswitch_Bank0
02B2: 57 62    MOV   X,0x62             (0099)     mov     X, <LoadConfigTBL_gpsswitch_Bank0
02B4: 7C 02 C5 LCALL 0x02C5             (0100)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0101) 
02B7: 50 01    MOV   A,0x1              (0102)     mov     a, 1                    ; Specify bank 1
02B9: 67       ASR   A                  (0103)     asr     a                       ; Store in carry flag
                                        (0104)                                     ; Load bank 1 table:
02BA: 50 01    MOV   A,0x1              (0105)     mov     A, >LoadConfigTBL_gpsswitch_Bank1
02BC: 57 9F    MOV   X,0x9F             (0106)     mov     X, <LoadConfigTBL_gpsswitch_Bank1
02BE: 7C 02 C5 LCALL 0x02C5             (0107)     lcall   LoadConfig              ; Load the bank 1 values
02C1: 70 EF    AND   F,0xEF             
                                        (0108) 
                                        (0109)     M8C_SetBank0                    ; Force return to bank 0
02C3: 20       POP   X                  (0110) 	pop		x
                                        (0111) 
                                        (0112)     RAM_EPILOGUE RAM_USE_CLASS_4
02C4: 7F       RET                      (0113)     ret
                                        (0114) 
                                        (0115) 
                                        (0116) 
                                        (0117) 
                                        (0118) ;---------------------------------------------------------------------------
                                        (0119) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0120) ;              pairs. Terminate on address=0xFF.
                                        (0121) ;
                                        (0122) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0123) ;           Flag Register Carry bit encodes the Register Bank
                                        (0124) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0125) ;
                                        (0126) ;  RETURNS: nothing.
                                        (0127) ;
                                        (0128) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0129) ;                X-3 Temporary store for register address
                                        (0130) ;                X-2 LSB of config table address
                                        (0131) ;                X-1 MSB of config table address
                                        (0132) ;
                                        (0133) LoadConfig:
                                        (0134)     RAM_PROLOGUE RAM_USE_CLASS_2
02C5: 38 02    ADD   SP,0x2             (0135)     add     SP, 2                   ; Set up local vars
02C7: 10       PUSH  X                  (0136)     push    X                       ; Save config table address on stack
02C8: 08       PUSH  A                  (0137)     push    A
02C9: 4F       MOV   X,SP               (0138)     mov     X, SP
02CA: 56 FC 00 MOV   [X-4],0x0          (0139)     mov     [X-4], 0                ; Set default Destination to Bank 0
02CD: D0 04    JNC   0x02D2             (0140)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
02CF: 56 FC 01 MOV   [X-4],0x1          (0141)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0142) .BankSelectSaved:
02D2: 18       POP   A                  (0143)     pop     A
02D3: 20       POP   X                  (0144)     pop     X
02D4: 70 EF    AND   F,0xEF             
02D6: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0145) 
                                        (0146) LoadConfigLp:
                                        (0147)     M8C_SetBank0                    ; Switch to bank 0
                                        (0148)     M8C_ClearWDT                    ; Clear the watchdog for long inits
02D9: 10       PUSH  X                  (0149)     push    X                       ; Preserve the config table address
02DA: 08       PUSH  A                  (0150)     push    A
02DB: 28       ROMX                     (0151)     romx                            ; Load register address from table
02DC: 39 FF    CMP   A,0xFF             (0152)     cmp     A, END_CONFIG_TABLE     ; End of table?
02DE: A0 1F    JZ    0x02FE             (0153)     jz      EndLoadConfig           ;   Yes, go wrap it up
02E0: 4F       MOV   X,SP               (0154)     mov     X, SP                   ;
02E1: 48 FC 01 TST   [X-4],0x1          (0155)     tst     [X-4], 1                ; Loading IO Bank 1?
02E4: A0 03    JZ    0x02E8             (0156)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
02E6: 71 10    OR    F,0x10             
                                        (0157)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0158) .IOBankNowSet:
02E8: 54 FD    MOV   [X-3],A            (0159)     mov     [X-3], A                ; Stash the register address
02EA: 18       POP   A                  (0160)     pop     A                       ; Retrieve the table address
02EB: 20       POP   X                  (0161)     pop     X
02EC: 75       INC   X                  (0162)     inc     X                       ; Advance to the data byte
02ED: 09 00    ADC   A,0x0              (0163)     adc     A, 0
02EF: 10       PUSH  X                  (0164)     push    X                       ; Save the config table address again
02F0: 08       PUSH  A                  (0165)     push    A
02F1: 28       ROMX                     (0166)     romx                            ; load config data from the table
02F2: 4F       MOV   X,SP               (0167)     mov     X, SP                   ; retrieve the register address
02F3: 59 FD    MOV   X,[X-3]            (0168)     mov     X, [X-3]
02F5: 61 00    MOV   REG[X+0x0],A       (0169)     mov     reg[X], A               ; Configure the register
02F7: 18       POP   A                  (0170)     pop     A                       ; retrieve the table address
02F8: 20       POP   X                  (0171)     pop     X
02F9: 75       INC   X                  (0172)     inc     X                       ; advance to next table entry
02FA: 09 00    ADC   A,0x0              (0173)     adc     A, 0
02FC: 8F D7    JMP   0x02D4             (0174)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0175) EndLoadConfig:
02FE: 38 FC    ADD   SP,0xFC            (0176)     add     SP, -4
                                        (0177)     RAM_EPILOGUE RAM_USE_CLASS_2
0300: 7F       RET                      (0178)     ret
                                        (0179) 
                                        (0180) AREA InterruptRAM(ram, rel)
                                        (0181) 
                                        (0182) NO_SHADOW:
                                        (0183) _NO_SHADOW:
                                        (0184) ; write only register shadows
                                        (0185) _Port_0_Data_SHADE:
                                        (0186) Port_0_Data_SHADE:	BLK	1
                                        (0187) 
FILE: lib\tx8int.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
0301: 08       PUSH  A                  (0003) ;;  FILENAME: TX8INT.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:27:52
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION:  TX8 Interrupt Service Rountine.
                                        (0008) ;;-----------------------------------------------------------------------------
0302: 51 15    MOV   A,[__r0]           (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
0304: 08       PUSH  A                  (0010) ;;*****************************************************************************
0305: 51 14    MOV   A,[__r1]           (0011) ;;*****************************************************************************
0307: 08       PUSH  A                  (0012) 
0308: 51 13    MOV   A,[__r2]           (0013) include "m8c.inc"
030A: 08       PUSH  A                  (0014) include "memory.inc"
030B: 51 12    MOV   A,[__r3]           (0015) include "TX8.inc"
030D: 08       PUSH  A                  (0016) 
030E: 51 11    MOV   A,[__r4]           (0017) 
0310: 08       PUSH  A                  (0018) ;-----------------------------------------------
0311: 51 10    MOV   A,[__r5]           (0019) ;  Global Symbols
0313: 08       PUSH  A                  (0020) ;-----------------------------------------------
0314: 51 0F    MOV   A,[__r6]           (0021) export  _TX8_ISR
0316: 08       PUSH  A                  (0022) 
0317: 51 0E    MOV   A,[__r7]           (0023) 
0319: 08       PUSH  A                  (0024) AREA InterruptRAM (RAM,REL,CON)
031A: 51 0D    MOV   A,[__r8]           (0025) 
031C: 08       PUSH  A                  (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
031D: 51 0C    MOV   A,[__r9]           (0027) ;---------------------------------------------------
031F: 08       PUSH  A                  (0028) ; Insert your custom declarations below this banner
0320: 51 0B    MOV   A,[__r10]          (0029) ;---------------------------------------------------
0322: 08       PUSH  A                  (0030) 
0323: 51 0A    MOV   A,[__r11]          (0031) ;------------------------
0325: 08       PUSH  A                  (0032) ; Includes
0326: 51 09    MOV   A,[__rX]           (0033) ;------------------------
0328: 08       PUSH  A                  (0034) 
0329: 51 08    MOV   A,[__rY]           (0035) 	
032B: 08       PUSH  A                  (0036) ;------------------------
032C: 51 07    MOV   A,[__rZ]           (0037) ;  Constant Definitions
032E: 08       PUSH  A                  (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _TX8_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _TX8_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
                                        (0075)    ;---------------------------------------------------
                                        (0076)    ; Insert a lcall to a C function below this banner
                                        (0077)    ; and un-comment the lines between these banners
                                        (0078)    ;---------------------------------------------------
                                        (0079)    
                                        (0080)    PRESERVE_CPU_CONTEXT
032F: 7C 06 1A LCALL _TX8_IRQ           (0081)    lcall _TX8_IRQ
0332: 18       POP   A                  
0333: 53 07    MOV   [__rZ],A           
0335: 18       POP   A                  
0336: 53 08    MOV   [__rY],A           
0338: 18       POP   A                  
0339: 53 09    MOV   [__rX],A           
033B: 18       POP   A                  
033C: 53 0A    MOV   [__r11],A          
033E: 18       POP   A                  
033F: 53 0B    MOV   [__r10],A          
0341: 18       POP   A                  
0342: 53 0C    MOV   [__r9],A           
0344: 18       POP   A                  
0345: 53 0D    MOV   [__r8],A           
0347: 18       POP   A                  
0348: 53 0E    MOV   [__r7],A           
034A: 18       POP   A                  
034B: 53 0F    MOV   [__r6],A           
034D: 18       POP   A                  
034E: 53 10    MOV   [__r5],A           
0350: 18       POP   A                  
0351: 53 11    MOV   [__r4],A           
0353: 18       POP   A                  
0354: 53 12    MOV   [__r3],A           
0356: 18       POP   A                  
0357: 53 13    MOV   [__r2],A           
0359: 18       POP   A                  
035A: 53 14    MOV   [__r1],A           
035C: 18       POP   A                  
035D: 53 15    MOV   [__r0],A           
035F: 18       POP   A                  
                                        (0082)    RESTORE_CPU_CONTEXT
                                        (0083)    
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ; Insert a lcall to a C function above this banner
                                        (0086)    ; and un-comment the lines between these banners
                                        (0087)    ;---------------------------------------------------
                                        (0088)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0089) 
0360: 7E       RETI                     (0090)    reti
                                        (0091) 
                                        (0092) 
                                        (0093) ; end of file TX8INT.asm
FILE: lib\tx8.asm                       (0001) ;;*****************************************************************************
0361: 43 E1 04 OR    REG[0xE1],0x4      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: TX8.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:27:52
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: TX8 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;-----------------------------------------------
                                        (0023) ; include instance specific register definitions
                                        (0024) ;-----------------------------------------------
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "TX8.inc"
                                        (0028) 
                                        (0029) area UserModules (ROM, REL)
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) export   TX8_SetTxIntMode
                                        (0034) export  _TX8_SetTxIntMode
                                        (0035) export   TX8_EnableInt
                                        (0036) export  _TX8_EnableInt
                                        (0037) export   TX8_DisableInt
                                        (0038) export  _TX8_DisableInt
                                        (0039) export   TX8_Start
                                        (0040) export  _TX8_Start
                                        (0041) export   TX8_Stop
                                        (0042) export  _TX8_Stop
                                        (0043) export   TX8_SendData
                                        (0044) export  _TX8_SendData
                                        (0045) export   TX8_bReadTxStatus
                                        (0046) export  _TX8_bReadTxStatus
                                        (0047) 
                                        (0048) // Old labels, will be removed in future release
                                        (0049) // Do Not Use.
                                        (0050) export   bTX8_ReadTxStatus
                                        (0051) export  _bTX8_ReadTxStatus
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ;  High Level TX functions
                                        (0055) ;-----------------------------------------------
                                        (0056) export  TX8_PutSHexByte
                                        (0057) export _TX8_PutSHexByte
                                        (0058) export  TX8_PutSHexInt
                                        (0059) export _TX8_PutSHexInt
                                        (0060) 
                                        (0061) export  TX8_CPutString
                                        (0062) export _TX8_CPutString
                                        (0063) export  TX8_PutString
                                        (0064) export _TX8_PutString
                                        (0065) export  TX8_PutChar
                                        (0066) export _TX8_PutChar
                                        (0067) export  TX8_Write
                                        (0068) export _TX8_Write
                                        (0069) export  TX8_CWrite
                                        (0070) export _TX8_CWrite
                                        (0071) export  TX8_PutCRLF
                                        (0072) export _TX8_PutCRLF 
                                        (0073) 
                                        (0074) ;-----------------------------------------------
                                        (0075) ;  EQUATES
                                        (0076) ;-----------------------------------------------
                                        (0077) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0078) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                        (0079) 
                                        (0080) AREA UserModules (ROM, REL)
                                        (0081) 
                                        (0082) .SECTION
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;  FUNCTION NAME: TX8_EnableInt
                                        (0085) ;
                                        (0086) ;  DESCRIPTION:
                                        (0087) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                        (0088) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0089) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0090) ;
                                        (0091) ;-----------------------------------------------------------------------------
                                        (0092) ;
                                        (0093) ;  ARGUMENTS: none
                                        (0094) ;
                                        (0095) ;  RETURNS: none
                                        (0096) ;
                                        (0097) ;  SIDE EFFECTS:
                                        (0098) ;    The A and X registers may be modified by this or future implementations
                                        (0099) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0100) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0101) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0102) ;    functions.
                                        (0103) ;
                                        (0104)  TX8_EnableInt:
                                        (0105) _TX8_EnableInt:
                                        (0106)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0107)    M8C_EnableIntMask  TX8_INT_REG, TX8_bINT_MASK
                                        (0108)    RAM_EPILOGUE RAM_USE_CLASS_1
0364: 7F       RET                      (0109)    ret
                                        (0110) .ENDSECTION
                                        (0111) 
                                        (0112) .SECTION
                                        (0113) ;-----------------------------------------------------------------------------
                                        (0114) ;  FUNCTION NAME: TX8_DisableInt
                                        (0115) ;
                                        (0116) ;  DESCRIPTION:
                                        (0117) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                        (0118) ;     associated with this User Module.
                                        (0119) ;
                                        (0120) ;-----------------------------------------------------------------------------
                                        (0121) ;
                                        (0122) ;  ARGUMENTS:  none
                                        (0123) ;
                                        (0124) ;  RETURNS:  none
                                        (0125) ;
                                        (0126) ;  SIDE EFFECTS:
                                        (0127) ;    The A and X registers may be modified by this or future implementations
                                        (0128) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0129) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0130) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0131) ;    functions.
                                        (0132) ;
                                        (0133)  TX8_DisableInt:
                                        (0134) _TX8_DisableInt:
                                        (0135)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0136)    M8C_DisableIntMask TX8_INT_REG, TX8_bINT_MASK
                                        (0137)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0138)    ret
                                        (0139) .ENDSECTION
                                        (0140) 
                                        (0141) .SECTION
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;  FUNCTION NAME: TX8_SetTxIntMode(BYTE bTxIntMode)
                                        (0144) ;
                                        (0145) ;  DESCRIPTION:
                                        (0146) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                        (0147) ;
                                        (0148) ;  ARGUMENTS:
                                        (0149) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                        (0150) ;        Passed in the A register
                                        (0151) ;
                                        (0152) ;  RETURNS:
                                        (0153) ;     none.
                                        (0154) ;
                                        (0155) ;  SIDE EFFECTS:
                                        (0156) ;    The A and X registers may be modified by this or future implementations
                                        (0157) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0158) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0159) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0160) ;    functions.
                                        (0161) ;
                                        (0162) ;  THEORY of OPERATION OR PROCEDURE:
                                        (0163) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                        (0164) ;     on TX register empty or TX transmit complete
                                        (0165) ;
                                        (0166)  TX8_SetTxIntMode:
                                        (0167) _TX8_SetTxIntMode:
                                        (0168)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0169)    M8C_SetBank1
                                        (0170)    and   A, TX8_INT_MODE_TX_COMPLETE
                                        (0171)    jz    .SetModeRegEmpty
                                        (0172)    or    REG[TX8_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                        (0173)    M8C_SetBank0
                                        (0174)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0175)    ret
                                        (0176) 
                                        (0177) .SetModeRegEmpty:
                                        (0178)    and   REG[TX8_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                        (0179)    M8C_SetBank0
                                        (0180)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0181)    ret
                                        (0182) .ENDSECTION
                                        (0183) 
                                        (0184) .SECTION
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;  FUNCTION NAME: TX8_Start(BYTE bParity)
                                        (0187) ;
                                        (0188) ;  DESCRIPTION:
                                        (0189) ;     Sets the start bit and parity in the Control register of this user module.
                                        (0190) ;     The transmitter will begin transmitting if a byte has been written into the
                                        (0191) ;     transmit buffer.
                                        (0192) ;
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) ;
                                        (0195) ;  ARGUMENTS:
                                        (0196) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                        (0197) ;
                                        (0198) ;  RETURNS:  none
                                        (0199) ;
                                        (0200) ;  SIDE EFFECTS:
                                        (0201) ;    The A and X registers may be modified by this or future implementations
                                        (0202) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0203) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0204) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0205) ;    functions.
                                        (0206) ;
                                        (0207)  TX8_Start:
                                        (0208) _TX8_Start:
                                        (0209)    RAM_PROLOGUE RAM_USE_CLASS_1
0365: 29 01    OR    A,0x1              (0210)    or    A, bfCONTROL_REG_START_BIT
0367: 60 2B    MOV   REG[0x2B],A        (0211)    mov   REG[TX8_CONTROL_REG], A
                                        (0212)    RAM_EPILOGUE RAM_USE_CLASS_1
0369: 7F       RET                      (0213)    ret
                                        (0214) .ENDSECTION
                                        (0215) 
                                        (0216) .SECTION
                                        (0217) ;-----------------------------------------------------------------------------
                                        (0218) ;  FUNCTION NAME: TX8_Stop
                                        (0219) ;
                                        (0220) ;  DESCRIPTION:
                                        (0221) ;     Disables TX8 operation.
                                        (0222) ;
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;
                                        (0225) ;  ARGUMENTS:  none
                                        (0226) ;
                                        (0227) ;  RETURNS:  none
                                        (0228) ;
                                        (0229) ;  SIDE EFFECTS:
                                        (0230) ;    The A and X registers may be modified by this or future implementations
                                        (0231) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0232) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0233) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0234) ;    functions.
                                        (0235) ;
                                        (0236)  TX8_Stop:
                                        (0237) _TX8_Stop:
                                        (0238)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0239)    and   REG[TX8_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0241)    ret
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: TX8_SendData
                                        (0247) ;
                                        (0248) ;  DESCRIPTION:
                                        (0249) ;     Sends one byte through serial port.
                                        (0250) ;
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;
                                        (0253) ;  ARGUMENTS:
                                        (0254) ;     BYTE  TxData - data to transmit.
                                        (0255) ;
                                        (0256) ;  RETURNS:
                                        (0257) ;
                                        (0258) ;  SIDE EFFECTS:
                                        (0259) ;    The A and X registers may be modified by this or future implementations
                                        (0260) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0261) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0262) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0263) ;    functions.
                                        (0264) ;
                                        (0265)  TX8_SendData:
                                        (0266) _TX8_SendData:
                                        (0267)    RAM_PROLOGUE RAM_USE_CLASS_1
036A: 60 29    MOV   REG[0x29],A        (0268)    mov REG[TX8_TX_BUFFER_REG], A
                                        (0269)    RAM_EPILOGUE RAM_USE_CLASS_1
036C: 7F       RET                      (0270)    ret
                                        (0271) .ENDSECTION
                                        (0272) 
                                        (0273) .SECTION
                                        (0274) ;-----------------------------------------------------------------------------
                                        (0275) ;  FUNCTION NAME: TX8_bReadTxStatus
                                        (0276) ;
                                        (0277) ;  DESCRIPTION:
                                        (0278) ;     Reads the Tx Status bits in the Control/Status register.
                                        (0279) ;
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;
                                        (0282) ;  ARGUMENTS:
                                        (0283) ;
                                        (0284) ;  RETURNS:
                                        (0285) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                        (0286) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                        (0287) ;
                                        (0288) ;  SIDE EFFECTS:
                                        (0289) ;    The A and X registers may be modified by this or future implementations
                                        (0290) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0291) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0292) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0293) ;    functions.
                                        (0294) ;
                                        (0295)  TX8_bReadTxStatus:
                                        (0296) _TX8_bReadTxStatus:
                                        (0297)  bTX8_ReadTxStatus:
                                        (0298) _bTX8_ReadTxStatus:
                                        (0299)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0300)    mov A,  REG[TX8_CONTROL_REG]
                                        (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0302)    ret
                                        (0303) 
                                        (0304) .ENDSECTION
                                        (0305) 
                                        (0306) ;-----------------------------------------------------------------------------
                                        (0307) ;  FUNCTION NAME: TX8_PutSHexByte
                                        (0308) ;
                                        (0309) ;  DESCRIPTION:
                                        (0310) ;     Print a byte in Hex (two characters) to the UART Tx
                                        (0311) ;
                                        (0312) ;  ARGUMENTS:
                                        (0313) ;     A  => (BYTE) Data/char to be printed
                                        (0314) ;
                                        (0315) ;  RETURNS:
                                        (0316) ;     none.
                                        (0317) ;
                                        (0318) ;  SIDE EFFECTS:
                                        (0319) ;    The A and X registers may be modified by this or future implementations
                                        (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0323) ;    functions.
                                        (0324) ;
                                        (0325) .LITERAL
                                        (0326) TX8_HEX_STR:
                                        (0327)      DS    "0123456789ABCDEF"
                                        (0328) .ENDLITERAL
                                        (0329) 
                                        (0330) .SECTION
                                        (0331)  TX8_PutSHexByte:
                                        (0332) _TX8_PutSHexByte:
                                        (0333)     RAM_PROLOGUE RAM_USE_CLASS_1
037D: 08       PUSH  A                  (0334)     push  A                            ; Save lower nibble
037E: 67       ASR   A                  (0335)     asr   A                            ; Shift high nibble to right
037F: 67       ASR   A                  (0336)     asr   A
0380: 67       ASR   A                  (0337)     asr   A
0381: 67       ASR   A                  (0338)     asr   A
0382: 21 0F    AND   A,0xF              (0339)     and   A,0Fh                        ; Mask off nibble
0384: FF E7    INDEX _bTX8_ReadTxStatus|_TX8_bReadTxStatus(0340)     index TX8_HEX_STR                  ; Get Hex value
0386: 90 08    CALL  _TX8_PutChar|_TX8_PutSHexInt(0341)     call  TX8_PutChar                  ; Write data to screen
0388: 18       POP   A                  (0342)     pop   A                            ; Restore value
0389: 21 0F    AND   A,0xF              (0343)     and   A,0Fh                        ; Mask off lower nibble
038B: FF E0    INDEX _bTX8_ReadTxStatus|_TX8_bReadTxStatus(0344)     index TX8_HEX_STR                  ; Get Hex value
038D: 90 01    CALL  _TX8_PutChar|_TX8_PutSHexInt(0345)     call  TX8_PutChar                  ; Write data to screen
                                        (0346)     RAM_EPILOGUE RAM_USE_CLASS_1
038F: 7F       RET                      (0347)     ret
0390: 49 2B 10 TST   REG[0x2B],0x10     
0393: AF FC    JZ    _TX8_PutChar|_TX8_PutSHexInt
0395: 60 29    MOV   REG[0x29],A        
                                        (0348) .ENDSECTION
                                        (0349) 
                                        (0350) .SECTION
                                        (0351) ;-----------------------------------------------------------------------------
                                        (0352) ;  FUNCTION NAME: TX8_PutSHexInt
                                        (0353) ;
                                        (0354) ;  DESCRIPTION:
                                        (0355) ;     Print an Int in Hex (four characters) to UART Tx
                                        (0356) ;
                                        (0357) ;  ARGUMENTS:
                                        (0358) ;     Pointer to string
                                        (0359) ;     A  => ASB of Int
                                        (0360) ;     X  => MSB of Int
                                        (0361) ;
                                        (0362) ;  RETURNS:
                                        (0363) ;     none.
                                        (0364) ;
                                        (0365) ;  SIDE EFFECTS:
                                        (0366) ;    The A and X registers may be modified by this or future implementations
                                        (0367) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0368) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0369) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0370) ;    functions.
                                        (0371) ;
                                        (0372)  TX8_PutSHexInt:
                                        (0373) _TX8_PutSHexInt:
                                        (0374)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0375)     swap  A,X
                                        (0376)     call  TX8_PutSHexByte              ; Print MSB
                                        (0377)     mov   A,X                          ; Move LSB into position
                                        (0378)     call  TX8_PutSHexByte              ; Print LSB
                                        (0379)     RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0380)     ret
                                        (0381) .ENDSECTION
                                        (0382) 
                                        (0383) .SECTION
                                        (0384) ;-----------------------------------------------------------------------------
                                        (0385) ;  FUNCTION NAME: TX8_PutChar
                                        (0386) ;
                                        (0387) ;  DESCRIPTION:
                                        (0388) ;     Send character out through UART TX port.
                                        (0389) ;
                                        (0390) ;
                                        (0391) ;  ARGUMENTS:
                                        (0392) ;     A has Character to send to UART Tx Port
                                        (0393) ;
                                        (0394) ;  RETURNS:
                                        (0395) ;     none
                                        (0396) ;
                                        (0397) ;  SIDE EFFECTS:
                                        (0398) ;    The A and X registers may be modified by this or future implementations
                                        (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0402) ;    functions.
                                        (0403) ;
                                        (0404)    macro InLinePutChar( Source )
                                        (0405) .BufEmptyWaitLoop:
                                        (0406)    tst REG[TX8_CONTROL_REG], TX8_TX_BUFFER_EMPTY    ; Check Tx Status
                                        (0407)    jz  .BufEmptyWaitLoop
                                        (0408)    mov REG[TX8_TX_BUFFER_REG], @Source    ; Write data to Tx Port
                                        (0409)    endm
                                        (0410) 
                                        (0411) 
                                        (0412)  TX8_PutChar:
                                        (0413) _TX8_PutChar:
                                        (0414)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0415)    InLinePutChar A
                                        (0416)    RAM_EPILOGUE RAM_USE_CLASS_1
0397: 7F       RET                      (0417)    ret
                                        (0418) 
                                        (0419) .ENDSECTION
                                        (0420) 
                                        (0421) 
                                        (0422) ;-----------------------------------------------
                                        (0423) ;  High Level TX functions
                                        (0424) ;-----------------------------------------------
                                        (0425) 
                                        (0426) 
                                        (0427) .SECTION
                                        (0428) ;-----------------------------------------------------------------------------
                                        (0429) ;  FUNCTION NAME: TX8_PutString
                                        (0430) ;
                                        (0431) ;  DESCRIPTION:
                                        (0432) ;     Send String out through UART TX port.
                                        (0433) ;
                                        (0434) ;
                                        (0435) ;  ARGUMENTS:
                                        (0436) ;     Pointer to String
                                        (0437) ;     A has MSB of string address
                                        (0438) ;     X has LSB of string address
                                        (0439) ;
                                        (0440) ;  RETURNS:
                                        (0441) ;     none
                                        (0442) ;
                                        (0443) ;  SIDE EFFECTS:
                                        (0444) ;    The A and X registers may be modified by this or future implementations
                                        (0445) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0446) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0447) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0448) ;    functions.
                                        (0449) ;          
                                        (0450) ;    Currently only the page pointer registers listed below are modified: 
                                        (0451) ;          IDX_PP
                                        (0452) ;
                                        (0453)  TX8_PutString:
                                        (0454) _TX8_PutString:
                                        (0455)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0456)    RAM_SETPAGE_IDX A
                                        (0457) .PutStringLoop:
0398: 52 00    MOV   A,[X+0]            (0458)    mov   A,[X]                             ; Get value pointed to by X
039A: A0 06    JZ    0x03A1             (0459)    jz    End_PutString                     ; Check for end of string
039C: 9F F2    CALL  _TX8_PutChar|_TX8_PutSHexInt(0460)    call  TX8_PutChar                        ; Send character to Tx port
039E: 75       INC   X                  (0461)    inc   X                                 ; Advance pointer to next character
039F: 8F F8    JMP   _TX8_PutString     (0462)    jmp   .PutStringLoop                     ; Get next character
                                        (0463) 
                                        (0464) End_PutString:
                                        (0465)    RAM_EPILOGUE RAM_USE_CLASS_3
03A1: 7F       RET                      (0466)    ret
                                        (0467) .ENDSECTION
                                        (0468) 
                                        (0469) .SECTION
                                        (0470) ;-----------------------------------------------------------------------------
                                        (0471) ;  FUNCTION NAME: TX8_Write
                                        (0472) ;
                                        (0473) ;  DESCRIPTION:
                                        (0474) ;     Send String of length X to serial port
                                        (0475) ;
                                        (0476) ;
                                        (0477) ;  ARGUMENTS:
                                        (0478) ;     Pointer to String
                                        (0479) ;     [SP-5] Count of characters to send
                                        (0480) ;     [SP-4] has MSB of string address
                                        (0481) ;     [SP-3] has LSB of string address
                                        (0482) ;
                                        (0483) ;  RETURNS:
                                        (0484) ;     none
                                        (0485) ;
                                        (0486) ;  SIDE EFFECTS:
                                        (0487) ;    The A and X registers may be modified by this or future implementations
                                        (0488) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0489) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0490) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0491) ;    functions.
                                        (0492) ;          
                                        (0493) ;    Currently only the page pointer registers listed below are modified: 
                                        (0494) ;          IDX_PP
                                        (0495) ;
                                        (0496) CNT_LEN:    equ -5           ; Length of data to send
                                        (0497) STR_MSB:    equ -4           ; MSB pointer of string
                                        (0498) STR_LSB:    equ -3           ; LSB pointer of string
                                        (0499) 
                                        (0500)  TX8_Write:
                                        (0501) _TX8_Write:
                                        (0502)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0503)    RAM_SETPAGE_IDX2STK
                                        (0504)    mov   X, SP
                                        (0505) 
                                        (0506) .NextByteLoop:
                                        (0507)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                        (0508)    jz    .End_Write
                                        (0509)    dec   [X+CNT_LEN]                       ; Decrement counter
                                        (0510) 
                                        (0511)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0512)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                        (0513)    ENDIF
                                        (0514) 
                                        (0515)    mov   X,[X+STR_LSB]                     ; Get character to send
                                        (0516)    RAM_SETPAGE_IDX A                        ; switch index pages
                                        (0517)    mov   A,[X]
                                        (0518)    InLinePutChar A                          ; Send character to UART
                                        (0519)    mov   X, SP
                                        (0520)    RAM_SETPAGE_IDX2STK
                                        (0521)    inc   [X+STR_LSB]
                                        (0522)    jmp   .NextByteLoop
                                        (0523) 
                                        (0524) .End_Write:
                                        (0525)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0526)    ret
                                        (0527) .ENDSECTION
                                        (0528) 
                                        (0529) .SECTION
                                        (0530) ;-----------------------------------------------------------------------------
                                        (0531) ;  FUNCTION NAME: TX8_CWrite
                                        (0532) ;
                                        (0533) ;             WARNING WARNING NOT COMPLETE
                                        (0534) ;
                                        (0535) ;  DESCRIPTION:
                                        (0536) ;     Send String of length X to serial port
                                        (0537) ;
                                        (0538) ;  ARGUMENTS:
                                        (0539) ;     Pointer to String
                                        (0540) ;     [SP-6] MSB of Count of character to send
                                        (0541) ;     [SP-5] LSB of Count of character to send
                                        (0542) ;     [SP-4] has MSB of string address
                                        (0543) ;     [SP-3] has LSB of string address
                                        (0544) ;
                                        (0545) ;  RETURNS:
                                        (0546) ;     none
                                        (0547) ;
                                        (0548) ;  SIDE EFFECTS:
                                        (0549) ;    The A and X registers may be modified by this or future implementations
                                        (0550) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0551) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0552) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0553) ;    functions.
                                        (0554) ;
                                        (0555) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                        (0556) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                        (0557) CSTR_MSB:   equ -4           ; MSB pointer of string
                                        (0558) CSTR_LSB:   equ -3           ; LSB pointer of string
                                        (0559) 
                                        (0560)  TX8_CWrite:
                                        (0561) _TX8_CWrite:
                                        (0562)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0563)    mov   X,SP
                                        (0564) 
                                        (0565) .CW_Loop:
                                        (0566)                                              ; Check for zero counter
                                        (0567)    cmp   [X+CLEN_MSB],0x00
                                        (0568)    jnz   .CW_WRITEIT
                                        (0569)    cmp   [X+CLEN_LSB],0x00
                                        (0570)    jz    .End_CWrite                         ; Leave if done
                                        (0571) 
                                        (0572) .CW_WRITEIT:                                 ; Save pointers
                                        (0573)    push  X
                                        (0574)    mov   A,[X+CSTR_MSB]
                                        (0575)    mov   X,[X+CSTR_LSB]
                                        (0576)    romx                                     ; Get character from ROM
                                        (0577)    InLinePutChar A
                                        (0578)    pop   X
                                        (0579) 
                                        (0580)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
                                        (0581)    adc   [X+CSTR_MSB],0
                                        (0582) 
                                        (0583)                                             ; Dec the counter
                                        (0584)    sub   [X+CLEN_LSB],0x01
                                        (0585)    sbb   [X+CLEN_MSB],0x00
                                        (0586) 
                                        (0587)    jmp   .CW_Loop
                                        (0588) 
                                        (0589) .End_CWrite:
                                        (0590)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0591)    ret
                                        (0592) .ENDSECTION
                                        (0593) 
                                        (0594) .SECTION
                                        (0595) ;-----------------------------------------------------------------------------
                                        (0596) ;  FUNCTION NAME: TX8_CPutString
                                        (0597) ;
                                        (0598) ;  DESCRIPTION:
                                        (0599) ;     Send String out through UART TX port.
                                        (0600) ;
                                        (0601) ;
                                        (0602) ;  ARGUMENTS:
                                        (0603) ;     Pointer to String
                                        (0604) ;     A has MSB of string address
                                        (0605) ;     X has LSB of string address
                                        (0606) ;
                                        (0607) ;  RETURNS:
                                        (0608) ;     none
                                        (0609) ;
                                        (0610) ;  SIDE EFFECTS:
                                        (0611) ;    The A and X registers may be modified by this or future implementations
                                        (0612) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0613) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0614) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0615) ;    functions.
                                        (0616) ;
                                        (0617)  TX8_CPutString:
                                        (0618) _TX8_CPutString:
                                        (0619)    RAM_PROLOGUE RAM_USE_CLASS_1   
03A2: 08       PUSH  A                  (0620)    push  A                                       ; Store ROM pointer
03A3: 10       PUSH  X                  (0621)    push  X
03A4: 28       ROMX                     (0622)    romx                                          ; Get character from ROM
03A5: A0 0B    JZ    0x03B1             (0623)    jz    .End_CPutString
03A7: 9F E7    CALL  _TX8_PutChar|_TX8_PutSHexInt(0624)    call  TX8_PutChar                        ; Print character
03A9: 20       POP   X                  (0625)    pop   X
03AA: 18       POP   A                  (0626)    pop   A
03AB: 75       INC   X                  (0627)    inc   X                                       ; Inc LSB of pointer
03AC: DF F5    JNC   _TX8_CWrite|_TX8_CPutString|_TX8_Write|TX8_CPutString(0628)    jnc   TX8_CPutString                          ; Check for carry
03AE: 74       INC   A                  (0629)    inc   A                                       ; Inc MSB of pointer
03AF: 8F F2    JMP   _TX8_CWrite|_TX8_CPutString|_TX8_Write|TX8_CPutString(0630)    jmp   TX8_CPutString
                                        (0631) 
                                        (0632) 
                                        (0633) .End_CPutString:
03B1: 38 FE    ADD   SP,0xFE            (0634)    add   SP, -2
                                        (0635)    RAM_EPILOGUE RAM_USE_CLASS_1
03B3: 7F       RET                      (0636)    ret
                                        (0637) .ENDSECTION
                                        (0638) 
                                        (0639) .SECTION
                                        (0640) ;-----------------------------------------------------------------------------
                                        (0641) ;  FUNCTION NAME: TX8_PutCRLF
                                        (0642) ;
                                        (0643) ;  DESCRIPTION:
                                        (0644) ;     Send a CR and LF
                                        (0645) ;
                                        (0646) ;  ARGUMENTS:
                                        (0647) ;     none.
                                        (0648) ;
                                        (0649) ;  RETURNS:
                                        (0650) ;     none.
                                        (0651) ;
                                        (0652) ;  SIDE EFFECTS:
                                        (0653) ;    The A and X registers may be modified by this or future implementations
                                        (0654) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0655) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0656) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0657) ;    functions.
                                        (0658) ;
                                        (0659)  TX8_PutCRLF:
                                        (0660) _TX8_PutCRLF:
                                        (0661)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0662)    mov  A,0x0D                        ; Send CR
                                        (0663)    call TX8_PutChar
                                        (0664)    mov  A,0x0A                        ; Send LF
                                        (0665)    call TX8_PutChar
                                        (0666)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0667)    ret
                                        (0668) .ENDSECTION
                                        (0669) 
                                        (0670) ; End of File TX8.asm
FILE: lib\rx8_2int.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
03B4: 08       PUSH  A                  (0003) ;;  FILENAME: RX8_2INT.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:26:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
03B5: 51 15    MOV   A,[__r0]           (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
03B7: 08       PUSH  A                  (0010) ;;*****************************************************************************
03B8: 51 14    MOV   A,[__r1]           (0011) ;;*****************************************************************************
03BA: 08       PUSH  A                  (0012) 
03BB: 51 13    MOV   A,[__r2]           (0013) include "m8c.inc"
03BD: 08       PUSH  A                  (0014) include "memory.inc"
03BE: 51 12    MOV   A,[__r3]           (0015) include "RX8_2.inc"
03C0: 08       PUSH  A                  (0016) 
03C1: 51 11    MOV   A,[__r4]           (0017) 
03C3: 08       PUSH  A                  (0018) ;-----------------------------------------------
03C4: 51 10    MOV   A,[__r5]           (0019) ;  Global Symbols
03C6: 08       PUSH  A                  (0020) ;-----------------------------------------------
03C7: 51 0F    MOV   A,[__r6]           (0021) export  _RX8_2_ISR
03C9: 08       PUSH  A                  (0022) 
03CA: 51 0E    MOV   A,[__r7]           (0023) 
03CC: 08       PUSH  A                  (0024) IF (RX8_2_RXBUF_ENABLE)
03CD: 51 0D    MOV   A,[__r8]           (0025) export  RX8_2_aRxBuffer
03CF: 08       PUSH  A                  (0026) export _RX8_2_aRxBuffer
03D0: 51 0C    MOV   A,[__r9]           (0027) export  RX8_2_bRxCnt
03D2: 08       PUSH  A                  (0028) export _RX8_2_bRxCnt
03D3: 51 0B    MOV   A,[__r10]          (0029) export  RX8_2_fStatus
03D5: 08       PUSH  A                  (0030) export _RX8_2_fStatus
03D6: 51 0A    MOV   A,[__r11]          (0031) ENDIF
03D8: 08       PUSH  A                  (0032) 
03D9: 51 09    MOV   A,[__rX]           (0033) 
03DB: 08       PUSH  A                  (0034) ;-----------------------------------------------
03DC: 51 08    MOV   A,[__rY]           (0035) ; Variable Allocation
03DE: 08       PUSH  A                  (0036) ;-----------------------------------------------
03DF: 51 07    MOV   A,[__rZ]           (0037) 
03E1: 08       PUSH  A                  (0038) IF (RX8_2_RXBUF_ENABLE)
                                        (0039) AREA InterruptRAM(RAM,REL,CON)
                                        (0040)  RX8_2_fStatus:
                                        (0041) _RX8_2_fStatus:      BLK  1
                                        (0042)  RX8_2_bRxCnt:
                                        (0043) _RX8_2_bRxCnt:       BLK  1
                                        (0044) AREA RX8_2_RAM(RAM,REL,CON)
                                        (0045)  RX8_2_aRxBuffer:    
                                        (0046) _RX8_2_aRxBuffer:    BLK RX8_2_RX_BUFFER_SIZE
                                        (0047) ENDIF
                                        (0048) 
                                        (0049) 
                                        (0050) AREA InterruptRAM(RAM,REL,CON)
                                        (0051) 
                                        (0052) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0053) ;---------------------------------------------------
                                        (0054) ; Insert your custom declarations below this banner
                                        (0055) ;---------------------------------------------------
                                        (0056) 
                                        (0057) ;------------------------
                                        (0058) ; Includes
                                        (0059) ;------------------------
                                        (0060) 
                                        (0061) 	
                                        (0062) ;------------------------
                                        (0063) ;  Constant Definitions
                                        (0064) ;------------------------
                                        (0065) 
                                        (0066) 
                                        (0067) ;------------------------
                                        (0068) ; Variable Allocation
                                        (0069) ;------------------------
                                        (0070) 
                                        (0071) 
                                        (0072) ;---------------------------------------------------
                                        (0073) ; Insert your custom declarations above this banner
                                        (0074) ;---------------------------------------------------
                                        (0075) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0076) 
                                        (0077) 
                                        (0078) AREA UserModules (ROM, REL)
                                        (0079) 
                                        (0080) ;-----------------------------------------------------------------------------
                                        (0081) ;  FUNCTION NAME: _RX8_2_ISR
                                        (0082) ;
                                        (0083) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0084) ;
                                        (0085) ;-----------------------------------------------------------------------------
                                        (0086) ;
                                        (0087) 
                                        (0088) _RX8_2_ISR:
                                        (0089) 
                                        (0090)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ; Insert your custom assembly code below this banner
                                        (0093)    ;---------------------------------------------------
                                        (0094)    ;   NOTE: interrupt service routines must preserve
                                        (0095)    ;   the values of the A and X CPU registers.
                                        (0096)    
                                        (0097)    ;---------------------------------------------------
                                        (0098)    ; Insert your custom assembly code above this banner
                                        (0099)    ;---------------------------------------------------
                                        (0100)    
                                        (0101)    ;---------------------------------------------------
                                        (0102)    ; Insert a lcall to a C function below this banner
                                        (0103)    ; and un-comment the lines between these banners
                                        (0104)    ;---------------------------------------------------
                                        (0105)    
                                        (0106)    PRESERVE_CPU_CONTEXT
03E2: 7C 05 E0 LCALL _RX8_2_IRQ         (0107)    lcall _RX8_2_IRQ
03E5: 18       POP   A                  
03E6: 53 07    MOV   [__rZ],A           
03E8: 18       POP   A                  
03E9: 53 08    MOV   [__rY],A           
03EB: 18       POP   A                  
03EC: 53 09    MOV   [__rX],A           
03EE: 18       POP   A                  
03EF: 53 0A    MOV   [__r11],A          
03F1: 18       POP   A                  
03F2: 53 0B    MOV   [__r10],A          
03F4: 18       POP   A                  
03F5: 53 0C    MOV   [__r9],A           
03F7: 18       POP   A                  
03F8: 53 0D    MOV   [__r8],A           
03FA: 18       POP   A                  
03FB: 53 0E    MOV   [__r7],A           
03FD: 18       POP   A                  
03FE: 53 0F    MOV   [__r6],A           
0400: 18       POP   A                  
0401: 53 10    MOV   [__r5],A           
0403: 18       POP   A                  
0404: 53 11    MOV   [__r4],A           
0406: 18       POP   A                  
0407: 53 12    MOV   [__r3],A           
0409: 18       POP   A                  
040A: 53 13    MOV   [__r2],A           
040C: 18       POP   A                  
040D: 53 14    MOV   [__r1],A           
040F: 18       POP   A                  
0410: 53 15    MOV   [__r0],A           
0412: 18       POP   A                  
                                        (0108)    RESTORE_CPU_CONTEXT
                                        (0109)    
                                        (0110)    ;---------------------------------------------------
                                        (0111)    ; Insert a lcall to a C function above this banner
                                        (0112)    ; and un-comment the lines between these banners
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0115) 
                                        (0116)  IF (RX8_2_RXBUF_ENABLE)
                                        (0117)    push A
                                        (0118)    push X
                                        (0119) 
                                        (0120)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0121)       REG_PRESERVE IDX_PP                                  ; Save the IDX_PP register	
                                        (0122)    ENDIF
                                        (0123) 
                                        (0124)    mov  X,[RX8_2_bRxCnt]                                   ; Load X with byte counter
                                        (0125)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Read the control register
                                        (0126)    push A                                                  ; Store copy for later test
                                        (0127)                                                            ; IF real RX interrupt
                                        (0128)    and  A,RX8_2_RX_REG_FULL                                ; Did really really get an IRQ
                                        (0129)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
                                        (0130)    pop  A                                                  ; Restore stack
                                        (0131)    jmp  .RESTORE_IDX_PP
                                        (0132) 
                                        (0133) .UARTRX_ReadRx:
                                        (0134) 
                                        (0135)    pop  A                                                  ; Restore status flags
                                        (0136)                                                            ; IF there is no error, get data
                                        (0137)                                                            ; Check for parity or framing error
                                        (0138)    and  A,RX8_2_RX_ERROR
                                        (0139)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
                                        (0140) 
                                        (0141)    or   [RX8_2_fStatus],A                                  ; Set error flags (parity,framing,overrun) bits
                                        (0142) 
                                        (0143)    tst  REG[RX8_2_RX_BUFFER_REG], 0x00                     ; Read the data buffer to clear it.
                                        (0144) 
                                        (0145)    and  A,RX8_2_RX_FRAMING_ERROR                           ; Check for framing error special case
                                        (0146)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
                                        (0147) 
                                        (0148)                                                            ; Disable and re-enable RX to reset after
                                        (0149)                                                            ; framing error.
                                        (0150)    and   REG[RX8_2_CONTROL_REG], ~RX8_2_RX_ENABLE          ; Disable RX
                                        (0151)    or    REG[RX8_2_CONTROL_REG],  RX8_2_RX_ENABLE          ; Enable RX
                                        (0152)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
                                        (0153) 
                                        (0154) 
                                        (0155) .UARTRX_NO_ERROR:
                                        (0156)    mov  A,REG[RX8_2_RX_BUFFER_REG ]                        ; Read the data buffer
                                        (0157) 
                                        (0158)                                                            ; IF buffer not full
                                        (0159)    tst  [RX8_2_fStatus],RX8_2_RX_BUF_CMDTERM               ; Check for buffer full
                                        (0160)    jnz  .RESTORE_IDX_PP                                    ; All done
                                        (0161) 
                                        (0162)    cmp  A,RX8_2_CMD_TERM                                   ; Check for End of command
                                        (0163)    jnz  .UARTRX_CHK_CTLCHAR
                                        (0164)    or   [RX8_2_fStatus],RX8_2_RX_BUF_CMDTERM               ; Set command ready bit
                                        (0165) 
                                        (0166)    RAM_SETPAGE_IDX >RX8_2_aRxBuffer
                                        (0167)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0168)    mov  [X + RX8_2_aRxBuffer],00h                          ; Zero out last data
                                        (0169)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0170)    jmp  .RESTORE_IDX_PP
                                        (0171) 
                                        (0172) .UARTRX_CHK_CTLCHAR:                                       ; Ignore charaters below this value
                                        (0173)                                                            ; If ignore char is set to 0x00, do not
                                        (0174)                                                            ; ignore any characters.
                                        (0175) IF(RX8_2_RX_IGNORE_BELOW)
                                        (0176)    cmp  A,RX8_2_RX_IGNORE_BELOW
                                        (0177)    jc   .RESTORE_IDX_PP
                                        (0178) ENDIF
                                        (0179) 
                                        (0180) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
                                        (0181)    cmp  [RX8_2_bRxCnt],(RX8_2_RX_BUFFER_SIZE - 1)
                                        (0182)    jc   .UARTRX_ISR_GETDATA
                                        (0183)    or   [RX8_2_fStatus],RX8_2_RX_BUF_OVERRUN               ; Set error flags (parity,framing,overrun) bits
                                        (0184) 
                                        (0185)    RAM_SETPAGE_IDX >RX8_2_aRxBuffer             ;   using idexed address mode
                                        (0186)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0187)    mov  [X + RX8_2_aRxBuffer],00h                          ; Zero out last data
                                        (0188)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0189)    jmp  .RESTORE_IDX_PP
                                        (0190) 
                                        (0191)                                                            ; IF input data == "CR", then end of command
                                        (0192) .UARTRX_ISR_GETDATA:
                                        (0193)    inc  X                                                  ; Inc the pointer
                                        (0194)    mov  [RX8_2_bRxCnt],X                                   ; Restore the pointer
                                        (0195)    dec  X                                                  ; Mov X to its original value
                                        (0196) 
                                        (0197)    RAM_SETPAGE_IDX >RX8_2_aRxBuffer             ;   using idexed address mode
                                        (0198)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0199)    mov  [X+RX8_2_aRxBuffer],A                              ; store data in array
                                        (0200)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0201) 
                                        (0202) 
                                        (0203) .RESTORE_IDX_PP:
                                        (0204)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0205)       REG_RESTORE IDX_PP
                                        (0206)    ENDIF
                                        (0207) 
                                        (0208) .END_UARTRX_ISR:
                                        (0209)    pop  X
                                        (0210)    pop  A
                                        (0211) 
                                        (0212) ENDIF
                                        (0213) 
                                        (0214) RX8_2_RX_ISR_END:
0413: 7E       RETI                     (0215)    reti
                                        (0216) 
                                        (0217) 
                                        (0218) ; end of file RX8_2INT.asm
FILE: lib\rx8_2.asm                     (0001) ;;*****************************************************************************
0414: 43 E1 40 OR    REG[0xE1],0x40     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: RX8_2.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:26:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;-----------------------------------------------
                                        (0023) ; include instance specific register definitions
                                        (0024) ;-----------------------------------------------
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "RX8_2.inc"
                                        (0028) 
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) export   RX8_2_EnableInt
                                        (0034) export  _RX8_2_EnableInt
                                        (0035) export   RX8_2_DisableInt
                                        (0036) export  _RX8_2_DisableInt
                                        (0037) export   RX8_2_Start
                                        (0038) export  _RX8_2_Start
                                        (0039) export   RX8_2_Stop
                                        (0040) export  _RX8_2_Stop
                                        (0041) export   RX8_2_bReadRxData
                                        (0042) export  _RX8_2_bReadRxData
                                        (0043) export   RX8_2_bReadRxStatus
                                        (0044) export  _RX8_2_bReadRxStatus
                                        (0045) 
                                        (0046) ; Old function name convension, do not use.
                                        (0047) ; These will be removed in a future release.
                                        (0048) export  bRX8_2_ReadRxData
                                        (0049) export _bRX8_2_ReadRxData
                                        (0050) export  bRX8_2_ReadRxStatus
                                        (0051) export _bRX8_2_ReadRxStatus
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ; High Level RX functions
                                        (0055) ;-----------------------------------------------
                                        (0056) 
                                        (0057) export  RX8_2_cGetChar
                                        (0058) export _RX8_2_cGetChar
                                        (0059) export  RX8_2_cReadChar
                                        (0060) export _RX8_2_cReadChar
                                        (0061) export  RX8_2_iReadChar
                                        (0062) export _RX8_2_iReadChar
                                        (0063) 
                                        (0064) IF (RX8_2_RXBUF_ENABLE)
                                        (0065) export  RX8_2_CmdReset
                                        (0066) export _RX8_2_CmdReset
                                        (0067) export  RX8_2_bCmdCheck
                                        (0068) export _RX8_2_bCmdCheck
                                        (0069) export  RX8_2_bCmdLength
                                        (0070) export _RX8_2_bCmdLength
                                        (0071) export  RX8_2_bErrCheck
                                        (0072) export _RX8_2_bErrCheck
                                        (0073) 
                                        (0074) export  RX8_2_szGetParam
                                        (0075) export _RX8_2_szGetParam
                                        (0076) export  RX8_2_szGetRestOfParams
                                        (0077) export _RX8_2_szGetRestOfParams
                                        (0078) 
                                        (0079) ;-----------------------------------------------
                                        (0080) ;  Variables
                                        (0081) ;-----------------------------------------------
                                        (0082) 
                                        (0083) AREA RX8_2_RAM(RAM,REL,CON)
                                        (0084)  ptrParam:   			BLK  1
                                        (0085) 
                                        (0086) ENDIF
                                        (0087) ;-----------------------------------------------
                                        (0088) ;  EQUATES
                                        (0089) ;-----------------------------------------------
                                        (0090) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0091) 
                                        (0092) area UserModules (ROM, REL)
                                        (0093) 
                                        (0094) .SECTION
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;  FUNCTION NAME: RX8_2_EnableInt
                                        (0097) ;
                                        (0098) ;  DESCRIPTION:
                                        (0099) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0100) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0101) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0102) ;
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;
                                        (0105) ;  ARGUMENTS: none
                                        (0106) ;
                                        (0107) ;  RETURNS: none
                                        (0108) ;
                                        (0109) ;  SIDE EFFECTS:
                                        (0110) ;    The A and X registers may be modified by this or future implementations
                                        (0111) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0112) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0113) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0114) ;    functions.
                                        (0115) ;
                                        (0116)  RX8_2_EnableInt:
                                        (0117) _RX8_2_EnableInt:
                                        (0118)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0119)    M8C_EnableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_1
0417: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) .SECTION
                                        (0125) ;-----------------------------------------------------------------------------
                                        (0126) ;  FUNCTION NAME: RX8_2_DisableInt
                                        (0127) ;
                                        (0128) ;  DESCRIPTION:
                                        (0129) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0130) ;     associated with this User Module.
                                        (0131) ;
                                        (0132) ;-----------------------------------------------------------------------------
                                        (0133) ;
                                        (0134) ;  ARGUMENTS:  none
                                        (0135) ;
                                        (0136) ;  RETURNS:  none
                                        (0137) ;
                                        (0138) ;  SIDE EFFECTS:
                                        (0139) ;    The A and X registers may be modified by this or future implementations
                                        (0140) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0141) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0142) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0143) ;    functions.
                                        (0144) ;
                                        (0145)  RX8_2_DisableInt:
                                        (0146) _RX8_2_DisableInt:
                                        (0147)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0148)    M8C_DisableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                        (0149)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0150)    ret
                                        (0151) .ENDSECTION
                                        (0152) 
                                        (0153) .SECTION
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: RX8_2_Start(BYTE bParity)
                                        (0156) ;
                                        (0157) ;  DESCRIPTION:
                                        (0158) ;    Sets the start bit and parity in the Control register of this user module.
                                        (0159) ;
                                        (0160) ;-----------------------------------------------------------------------------
                                        (0161) ;
                                        (0162) ;  ARGUMENTS:
                                        (0163) ;    BYTE bParity - parity of received data.  Use defined masks.
                                        (0164) ;    passed in A register.
                                        (0165) ;
                                        (0166) ;  RETURNS: none
                                        (0167) ;
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  RX8_2_Start:
                                        (0176) _RX8_2_Start:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
0418: 29 01    OR    A,0x1              (0178)    or    A, bfCONTROL_REG_START_BIT
041A: 60 3B    MOV   REG[0x3B],A        (0179)    mov   REG[RX8_2_CONTROL_REG], A
                                        (0180)    RAM_EPILOGUE RAM_USE_CLASS_1
041C: 7F       RET                      (0181)    ret
                                        (0182) .ENDSECTION
                                        (0183) 
                                        (0184) .SECTION
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;  FUNCTION NAME: RX8_2_Stop
                                        (0187) ;
                                        (0188) ;  DESCRIPTION:
                                        (0189) ;     Disables RX8 operation.
                                        (0190) ;
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: none
                                        (0194) ;
                                        (0195) ;  RETURNS: none
                                        (0196) ;
                                        (0197) ;  SIDE EFFECTS:
                                        (0198) ;    The A and X registers may be modified by this or future implementations
                                        (0199) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0200) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0201) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0202) ;    functions.
                                        (0203) ;
                                        (0204)  RX8_2_Stop:
                                        (0205) _RX8_2_Stop:
                                        (0206)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0207)    and   REG[RX8_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0208)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0209)    ret
                                        (0210) .ENDSECTION
                                        (0211) 
                                        (0212) .SECTION
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;  FUNCTION NAME: RX8_2_bReadRxData
                                        (0215) ;
                                        (0216) ;  DESCRIPTION:
                                        (0217) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0218) ;     sure data is valid.
                                        (0219) ;
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;
                                        (0222) ;  ARGUMENTS:  none
                                        (0223) ;
                                        (0224) ;  RETURNS:
                                        (0225) ;    bRxData - returned in A.
                                        (0226) ;
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  RX8_2_bReadRxData:
                                        (0235) _RX8_2_bReadRxData:
                                        (0236)  bRX8_2_ReadRxData:
                                        (0237) _bRX8_2_ReadRxData:
                                        (0238)    RAM_PROLOGUE RAM_USE_CLASS_1
041D: 5D 3A    MOV   A,REG[0x3A]        (0239)    mov A, REG[RX8_2_RX_BUFFER_REG]
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
041F: 7F       RET                      (0241)    ret
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: RX8_2_bReadRxStatus
                                        (0247) ;
                                        (0248) ;  DESCRIPTION:
                                        (0249) ;    Reads the RX Status bits in the Control/Status register.
                                        (0250) ;
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;
                                        (0253) ;  ARGUMENTS:  none
                                        (0254) ;
                                        (0255) ;  RETURNS:
                                        (0256) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                        (0257) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0258) ;
                                        (0259) ;  SIDE EFFECTS:
                                        (0260) ;    The A and X registers may be modified by this or future implementations
                                        (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0264) ;    functions.
                                        (0265) ;
                                        (0266)  RX8_2_bReadRxStatus:
                                        (0267) _RX8_2_bReadRxStatus:
                                        (0268)  bRX8_2_ReadRxStatus:
                                        (0269) _bRX8_2_ReadRxStatus:
                                        (0270)    RAM_PROLOGUE RAM_USE_CLASS_1
0420: 5D 3B    MOV   A,REG[0x3B]        (0271)    mov A,  REG[RX8_2_CONTROL_REG]
                                        (0272)    RAM_EPILOGUE RAM_USE_CLASS_1
0422: 7F       RET                      (0273)    ret
                                        (0274) .ENDSECTION
                                        (0275) 
                                        (0276) ;-----------------------------------------------
                                        (0277) ; High Level RX functions
                                        (0278) ;-----------------------------------------------
                                        (0279) 
                                        (0280) .SECTION
                                        (0281) ;-----------------------------------------------------------------------------
                                        (0282) ;  FUNCTION NAME: RX8_2_cGetChar
                                        (0283) ;
                                        (0284) ;  DESCRIPTION:
                                        (0285) ;     Read character from UART RX port.
                                        (0286) ;
                                        (0287) ;
                                        (0288) ;  ARGUMENTS:
                                        (0289) ;      none
                                        (0290) ;
                                        (0291) ;  RETURNS:
                                        (0292) ;     char that is returned from UART
                                        (0293) ;
                                        (0294) ;  SIDE EFFECTS:
                                        (0295) ;    The A and X registers may be modified by this or future implementations
                                        (0296) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0297) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0298) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0299) ;    functions.
                                        (0300) ;    
                                        (0301) ;    Program flow will stay in this function until a character is received.
                                        (0302) ;    If the watchdog timer is used, care must be taken to make sure that
                                        (0303) ;    the delay between characters is less than the watchdog timeout.
                                        (0304) ;
                                        (0305)  RX8_2_cGetChar:
                                        (0306) _RX8_2_cGetChar:
                                        (0307)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0308) 
                                        (0309) .getChar_Loop:
0423: 49 3B 08 TST   REG[0x3B],0x8      (0310)    tst REG[RX8_2_CONTROL_REG],RX8_2_RX_REG_FULL  ; Check if a character is ready
0426: AF FC    JZ    _RX8_2_cGetChar    (0311)    jz  .getChar_Loop                                        ; If not loop
                                        (0312) 
0428: 5D 3A    MOV   A,REG[0x3A]        (0313)    mov A, REG[RX8_2_RX_BUFFER_REG]               ; Get character
                                        (0314)    RAM_EPILOGUE RAM_USE_CLASS_1
042A: 7F       RET                      (0315)    ret
                                        (0316) .ENDSECTION
                                        (0317) 
                                        (0318) .SECTION
                                        (0319) ;-----------------------------------------------------------------------------
                                        (0320) ;  FUNCTION NAME: RX8_2_cReadChar
                                        (0321) ;
                                        (0322) ;  DESCRIPTION:
                                        (0323) ;     Read character from UART RX port.
                                        (0324) ;
                                        (0325) ;  ARGUMENTS:
                                        (0326) ;      none
                                        (0327) ;
                                        (0328) ;  RETURNS:
                                        (0329) ;     char that is returned from UART
                                        (0330) ;
                                        (0331) ;  SIDE EFFECTS:
                                        (0332) ;    The A and X registers may be modified by this or future implementations
                                        (0333) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0334) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0335) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0336) ;    functions.
                                        (0337) ;
                                        (0338) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                        (0339) ;    implies a valid character or an error condition occured.
                                        (0340) ;
                                        (0341)  RX8_2_cReadChar:
                                        (0342) _RX8_2_cReadChar:
                                        (0343)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0344) 
                                        (0345)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                        (0346)    push A
                                        (0347)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
                                        (0348)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
                                        (0349)    pop  A
                                        (0350)    jmp  .RX_NO_VALID_CHAR
                                        (0351) 
                                        (0352) .RX_DATA_RDY:
                                        (0353)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
                                        (0354)    swap A,X                                                ; determine if data is valid
                                        (0355) 
                                        (0356)    pop  A                                                  ; Check for errors
                                        (0357)    and  A,(RX8_2_RX_PARITY_ERROR | RX8_2_RX_FRAMING_ERROR)
                                        (0358)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                        (0359)    swap A,X                                                ; Put data in A and exit
                                        (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0361)    ret
                                        (0362) 
                                        (0363) .RX_NO_VALID_CHAR:
                                        (0364)    mov A,0x00                                              ; Zero out character
                                        (0365) 
                                        (0366)  End_RX8_2_cReadChar:
                                        (0367)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0368)    ret
                                        (0369) .ENDSECTION
                                        (0370) 																			
                                        (0371) .SECTION
                                        (0372) ;-----------------------------------------------------------------------------
                                        (0373) ;  FUNCTION NAME: RX8_2_iReadChar
                                        (0374) ;
                                        (0375) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                        (0376) ; to just set a value in the upper byte if error conditions exists.
                                        (0377) ;
                                        (0378) ;  DESCRIPTION:
                                        (0379) ;     Read character from UART RX port.
                                        (0380) ;
                                        (0381) ;  ARGUMENTS:
                                        (0382) ;      none
                                        (0383) ;
                                        (0384) ;  RETURNS:
                                        (0385) ;     An integer value is returned.  A negative value inplies and error
                                        (0386) ;     condition, a positive value between 0 and 255 is the return character.
                                        (0387) ;
                                        (0388) ;     Error Codes:
                                        (0389) ;        0x80CC    Parity Error
                                        (0390) ;        0x40CC    Overrun Error
                                        (0391) ;        0x20CC    Framing Error
                                        (0392) ;        0x01CC    No Data available
                                        (0393) ;
                                        (0394) ;  SIDE EFFECTS:
                                        (0395) ;    The A and X registers may be modified by this or future implementations
                                        (0396) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0397) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0398) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0399) ;    functions.
                                        (0400) ;
                                        (0401)  RX8_2_iReadChar:
                                        (0402) _RX8_2_iReadChar:
                                        (0403)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0404) 
                                        (0405)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                        (0406)                                                            ; Mask only errors and data ready
                                        (0407)    and  A,(RX8_2_RX_ERROR|RX8_2_RX_REG_FULL)
                                        (0408)    push A
                                        (0409)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
                                        (0410)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                        (0411)    pop  A
                                        (0412)    or   A,RX8_2_RX_NO_DATA                                 ; Add no data flag
                                        (0413)    swap A,X
                                        (0414)    jmp  End_RX8_2_iReadChar
                                        (0415) 
                                        (0416) .RX_GET_DATA:
                                        (0417)    pop  A
                                        (0418)    and  A,RX8_2_RX_ERROR
                                        (0419)    swap A,X
                                        (0420)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
                                        (0421)                                                            ; determine if data is valid
                                        (0422) 
                                        (0423)  End_RX8_2_iReadChar:
                                        (0424)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0425)    ret
                                        (0426) .ENDSECTION
                                        (0427) 
                                        (0428) 
                                        (0429) 
                                        (0430) IF (RX8_2_RXBUF_ENABLE)
                                        (0431) .SECTION
                                        (0432) ;-----------------------------------------------------------------------------
                                        (0433) ;-----------------------------------------------------------------------------
                                        (0434) ;
                                        (0435) ;     Command Buffer commands
                                        (0436) ;
                                        (0437) ;-----------------------------------------------------------------------------
                                        (0438) ;-----------------------------------------------------------------------------
                                        (0439) 
                                        (0440) ;-----------------------------------------------------------------------------
                                        (0441) ;  FUNCTION NAME: RX8_2_CmdReset
                                        (0442) ;
                                        (0443) ;  DESCRIPTION:
                                        (0444) ;     Reset command string and status flags
                                        (0445) ;
                                        (0446) ;  ARGUMENTS:
                                        (0447) ;     none.
                                        (0448) ;
                                        (0449) ;  RETURNS:
                                        (0450) ;     none.
                                        (0451) ;
                                        (0452) ;  SIDE EFFECTS:
                                        (0453) ;    The A and X registers may be modified by this or future implementations
                                        (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0457) ;    functions.
                                        (0458) ;          
                                        (0459) ;    Currently only the page pointer registers listed below are modified: 
                                        (0460) ;          CUR_PP
                                        (0461) ;
                                        (0462) ;  THEORY of OPERATION or PROCEDURE:
                                        (0463) ;     Clear the command buffer, command counter, and flag.
                                        (0464) ;
                                        (0465)  RX8_2_CmdReset:
                                        (0466) _RX8_2_CmdReset:
                                        (0467)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0468)    RAM_SETPAGE_CUR >RX8_2_aRxBuffer
                                        (0469)    mov [RX8_2_aRxBuffer], 0x00
                                        (0470)    RAM_SETPAGE_CUR >ptrParam
                                        (0471)    mov [ptrParam],0x00
                                        (0472)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
                                        (0473)    mov [RX8_2_bRxCnt], 0x00
                                        (0474)    and [RX8_2_fStatus], 0x00
                                        (0475)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0476)    ret
                                        (0477) .ENDSECTION
                                        (0478) 
                                        (0479) .SECTION
                                        (0480) ;-----------------------------------------------------------------------------
                                        (0481) ;  FUNCTION NAME: RX8_2_bCmdCheck
                                        (0482) ;
                                        (0483) ;  DESCRIPTION:
                                        (0484) ;     Check to see if valid command in buffer.
                                        (0485) ;
                                        (0486) ;  ARGUMENTS:
                                        (0487) ;     none.
                                        (0488) ;
                                        (0489) ;  RETURNS:
                                        (0490) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0491) ;                     Returns non-zero value in A if command is valid.
                                        (0492) ;
                                        (0493) ;  SIDE EFFECTS:
                                        (0494) ;    The A and X registers may be modified by this or future implementations
                                        (0495) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0496) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0497) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0498) ;    functions.
                                        (0499) ;          
                                        (0500) ;    Currently only the page pointer registers listed below are modified: 
                                        (0501) ;          CUR_PP
                                        (0502) ;
                                        (0503) ;  THEORY of OPERATION or PROCEDURE:
                                        (0504) ;     Read the status and control register.
                                        (0505) ;
                                        (0506)  RX8_2_bCmdCheck:
                                        (0507) _RX8_2_bCmdCheck:
                                        (0508)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0509)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                        (0510)    mov A,  [RX8_2_fStatus]
                                        (0511)    and A, RX8_2_RX_BUF_CMDTERM                   ; Mask off Command status
                                        (0512)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0513)    ret
                                        (0514) .ENDSECTION
                                        (0515) 
                                        (0516) .SECTION
                                        (0517) ;-----------------------------------------------------------------------------
                                        (0518) ;  FUNCTION NAME: RX8_2_bErrCheck
                                        (0519) ;
                                        (0520) ;  DESCRIPTION:
                                        (0521) ;     Check to see if an error has occured since last CmdReset
                                        (0522) ;
                                        (0523) ;  ARGUMENTS:
                                        (0524) ;     none.
                                        (0525) ;
                                        (0526) ;  RETURNS:
                                        (0527) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0528) ;                     Returns non-zero value in A if command is valid.
                                        (0529) ;           0x80 => Parity Error
                                        (0530) ;           0x40 => OverRun Error
                                        (0531) ;           0x20 => Framing Error
                                        (0532) ;           0x10 => Software Buffer OverRun
                                        (0533) ;
                                        (0534) ;  SIDE EFFECTS:
                                        (0535) ;    The A and X registers may be modified by this or future implementations
                                        (0536) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0537) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0538) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0539) ;    functions.
                                        (0540) ;          
                                        (0541) ;    Currently only the page pointer registers listed below are modified: 
                                        (0542) ;          CUR_PP
                                        (0543) ;
                                        (0544) ;     Error Status is clear when read.
                                        (0545) ;
                                        (0546) ;  THEORY of OPERATION or PROCEDURE:
                                        (0547) ;     Read RX buffer error status and clear status
                                        (0548) ;
                                        (0549)  RX8_2_bErrCheck:
                                        (0550) _RX8_2_bErrCheck:
                                        (0551)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0552)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                        (0553)    mov A,  [RX8_2_fStatus]
                                        (0554)    and A, RX8_2_RX_BUF_ERROR                     ; Mask off Error status
                                        (0555)    and [RX8_2_fStatus], ~RX8_2_RX_BUF_ERROR
                                        (0556)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0557)    ret
                                        (0558) .ENDSECTION
                                        (0559) 
                                        (0560) .SECTION
                                        (0561) ;-----------------------------------------------------------------------------
                                        (0562) ;  FUNCTION NAME: RX8_2_bCmdLength
                                        (0563) ;
                                        (0564) ;  DESCRIPTION:
                                        (0565) ;     Get length of command string
                                        (0566) ;
                                        (0567) ;  ARGUMENTS:
                                        (0568) ;     none.
                                        (0569) ;
                                        (0570) ;  RETURNS:
                                        (0571) ;     BYTE  bRxCnt    Returns the command length in A.
                                        (0572) ;
                                        (0573) ;  SIDE EFFECTS:
                                        (0574) ;    The A and X registers may be modified by this or future implementations
                                        (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0578) ;    functions.
                                        (0579) ;          
                                        (0580) ;    Currently only the page pointer registers listed below are modified: 
                                        (0581) ;          CUR_PP
                                        (0582) ;
                                        (0583)  RX8_2_bCmdLength:
                                        (0584) _RX8_2_bCmdLength:
                                        (0585)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
                                        (0587)    mov A,  [RX8_2_bRxCnt]
                                        (0588)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0589)    ret
                                        (0590) .ENDSECTION
                                        (0591) 
                                        (0592) .SECTION
                                        (0593) ;-----------------------------------------------------------------------------
                                        (0594) ;  FUNCTION NAME: RX8_2_szGetParam
                                        (0595) ;
                                        (0596) ;  DESCRIPTION:
                                        (0597) ;      Return next parameter from UART Rx buffer
                                        (0598) ;
                                        (0599) ;
                                        (0600) ;  ARGUMENTS:  none
                                        (0601) ;
                                        (0602) ;  RETURNS:
                                        (0603) ;     A => MSB of parameter address
                                        (0604) ;     X => LSB of parameter address
                                        (0605) ;
                                        (0606) ;  SIDE EFFECTS:
                                        (0607) ;    The A and X registers may be modified by this or future implementations
                                        (0608) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0609) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0610) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0611) ;    functions.
                                        (0612) ;          
                                        (0613) ;    Currently only the page pointer registers listed below are modified:
                                        (0614) ;          CUR_PP
                                        (0615) ;          IDX_PP
                                        (0616) ;
                                        (0617) ;     The receive string is modified by placing Null characters at the end
                                        (0618) ;     of each parameter as they are recovered.
                                        (0619) ;
                                        (0620) ;  THEORY OF OPERATION:
                                        (0621) ;     This function is a stateful generator of addresses to the "parameters"
                                        (0622) ;     of an input "Command". It scans the (optional) input buffer and breaks
                                        (0623) ;     each lexically distinct element into a null-terminated string by replacing
                                        (0624) ;     delimiters with nulls, as appropriate. The state of the generator is 
                                        (0625) ;     maintained by the private variable ptrParam, which is a buffer-relative
                                        (0626) ;     offset. The generator is initialized by a call to the function
                                        (0627) ;     RX8_2_CmdReset which resets the entire buffer to the 'empty'
                                        (0628) ;     state. Typically this function, RX8_2_szGetParam, is
                                        (0629) ;     not called until the buffer has been loaded with an entire command
                                        (0630) ;     (See RX8_2_bCmdCheck).
                                        (0631) ;
                                        (0632) ;     Note, there is no special distinction between the "command" and the 
                                        (0633) ;     "parameters". The first non-delimiter character of the buffer---the first
                                        (0634) ;     character of the "command"---is also, for the purposes of this function,
                                        (0635) ;     the first "parameter" to which it returns an address.
                                        (0636) ;
                                        (0637) ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
                                        (0638) ;     is determined at configuration time by a user module parameter.
                                        (0639) ;
                                        (0640)  RX8_2_szGetParam:
                                        (0641) _RX8_2_szGetParam:
                                        (0642)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0643)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0644)    RAM_SETPAGE_CUR >ptrParam
                                        (0645)    RAM_SETPAGE_IDX >RX8_2_aRxBuffer
                                        (0646) 
                                        (0647)    mov  A, <RX8_2_aRxBuffer                 ; Get address to receive buffer
                                        (0648)    add  A, [ptrParam]                      ; Add string offset
                                        (0649)    mov  X,A
                                        (0650) 
                                        (0651)    mov  A,[X]                              ; Get character pointed by X
                                        (0652)    jnz  .CheckForDelim                     ; Check for Null character
                                        (0653)    push X                                  ; Save LSB of current pointer
                                        (0654)    jmp  .End_GetNextParam
                                        (0655) 
                                        (0656)                                             ; Check for delimiter and keep looping until
                                        (0657)                                             ; all leading delimiters have been found.
                                        (0658) .CheckForDelim:
                                        (0659)     cmp  A,RX8_2_DELIMITER                  ; Check if we have a delimiter
                                        (0660)     jnz  .ParamStartFound
                                        (0661)     inc  X                                  ; Increment both current pointer and
                                        (0662)     inc  [ptrParam]                         ; stored pointer.
                                        (0663)     mov  A,[X]                              ; Get character pointed by X
                                        (0664)     cmp  [ptrParam],(RX8_2_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0665)     jnz  .CheckForDelim
                                        (0666)                                             ; End of string found
                                        (0667) .EndOfString:
                                        (0668)     push X                                  ; Save ptr
                                        (0669) .TerminateString:
                                        (0670)     mov  [X],0x00                           ; Make sure string is zero
                                        (0671)     jmp  .End_GetNextParam
                                        (0672) 
                                        (0673) .ParamStartFound:
                                        (0674)     push X                                  ; Beginning of parameter found, save pointer
                                        (0675) 
                                        (0676) .ParamLoop:
                                        (0677)                                             ; Now loop until end of parameter found.
                                        (0678)     inc  X                                  ; Advance pointers.
                                        (0679)     inc  [ptrParam]
                                        (0680)     cmp  [ptrParam],(RX8_2_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0681)     jz   .TerminateString
                                        (0682)     mov  A,[X]                              ; Get next character
                                        (0683)     jz   .End_GetNextParam
                                        (0684)     cmp  A,RX8_2_DELIMITER                  ; Check if we have a delimiter
                                        (0685)     jnz  .ParamLoop                         ; Still no delimiter, loop again
                                        (0686) 
                                        (0687)     mov  [X],0x00                           ; Replace delimiter with null for end of substring
                                        (0688)     inc  [ptrParam]
                                        (0689)     cmp  [ptrParam],(RX8_2_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0690)     jnz  .End_GetNextParam                  ; If not end of string leave
                                        (0691)     mov  [ptrParam],(RX8_2_RX_BUFFER_SIZE -1)  ; Reset pointer to end of string.
                                        (0692) 
                                        (0693) 
                                        (0694) .End_GetNextParam:
                                        (0695)    pop  X
                                        (0696)    push X
                                        (0697)    cmp  [X],0x00
                                        (0698)    jnz  .NotNullString
                                        (0699)    pop  X
                                        (0700)    mov  X,0x00
                                        (0701)    mov  A,X
                                        (0702)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0703)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0704)    ret
                                        (0705) 
                                        (0706) .NotNullString:
                                        (0707)    pop  X
                                        (0708)    mov  A,>RX8_2_aRxBuffer                     ; Return pointer
                                        (0709)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0710)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0711)    ret
                                        (0712) .ENDSECTION
                                        (0713) 
                                        (0714) .SECTION
                                        (0715) ;-----------------------------------------------------------------------------
                                        (0716) ;  FUNCTION NAME: RX8_2_szGetRestOfParams
                                        (0717) ;
                                        (0718) ;  DESCRIPTION:
                                        (0719) ;      Return the rest of the UART RX buffer
                                        (0720) ;
                                        (0721) ;
                                        (0722) ;  ARGUMENTS:  none
                                        (0723) ;
                                        (0724) ;  RETURNS:
                                        (0725) ;     A => MSB of parameter
                                        (0726) ;     X => LSB of parameter
                                        (0727) ;
                                        (0728) ;  SIDE EFFECTS:
                                        (0729) ;    The A and X registers may be modified by this or future implementations
                                        (0730) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0731) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0732) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0733) ;    functions.
                                        (0734) ;          
                                        (0735) ;    Currently only the page pointer registers listed below are modified: 
                                        (0736) ;          CUR_PP
                                        (0737) ;
                                        (0738)  RX8_2_szGetRestOfParams:
                                        (0739) _RX8_2_szGetRestOfParams:
                                        (0740)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0741)    RAM_SETPAGE_CUR >ptrParam
                                        (0742) 
                                        (0743)     mov  A, <RX8_2_aRxBuffer                ; Get address to receive buffer
                                        (0744)     add  A, [ptrParam]                      ; Add string offset
                                        (0745)     mov  X,A
                                        (0746)     mov  A,>RX8_2_aRxBuffer                 ; Return pointer
                                        (0747) 
                                        (0748)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0749)     ret
                                        (0750) .ENDSECTION
                                        (0751) 
                                        (0752) ENDIF
                                        (0753) ; End of File RX8_2.asm
FILE: lib\rx8_1int.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
042B: 08       PUSH  A                  (0003) ;;  FILENAME: RX8_1INT.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:26:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
                                        (0008) ;;-----------------------------------------------------------------------------
042C: 51 15    MOV   A,[__r0]           (0009) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
042E: 08       PUSH  A                  (0010) ;;*****************************************************************************
042F: 51 14    MOV   A,[__r1]           (0011) ;;*****************************************************************************
0431: 08       PUSH  A                  (0012) 
0432: 51 13    MOV   A,[__r2]           (0013) include "m8c.inc"
0434: 08       PUSH  A                  (0014) include "memory.inc"
0435: 51 12    MOV   A,[__r3]           (0015) include "RX8_1.inc"
0437: 08       PUSH  A                  (0016) 
0438: 51 11    MOV   A,[__r4]           (0017) 
043A: 08       PUSH  A                  (0018) ;-----------------------------------------------
043B: 51 10    MOV   A,[__r5]           (0019) ;  Global Symbols
043D: 08       PUSH  A                  (0020) ;-----------------------------------------------
043E: 51 0F    MOV   A,[__r6]           (0021) export  _RX8_1_ISR
0440: 08       PUSH  A                  (0022) 
0441: 51 0E    MOV   A,[__r7]           (0023) 
0443: 08       PUSH  A                  (0024) IF (RX8_1_RXBUF_ENABLE)
0444: 51 0D    MOV   A,[__r8]           (0025) export  RX8_1_aRxBuffer
0446: 08       PUSH  A                  (0026) export _RX8_1_aRxBuffer
0447: 51 0C    MOV   A,[__r9]           (0027) export  RX8_1_bRxCnt
0449: 08       PUSH  A                  (0028) export _RX8_1_bRxCnt
044A: 51 0B    MOV   A,[__r10]          (0029) export  RX8_1_fStatus
044C: 08       PUSH  A                  (0030) export _RX8_1_fStatus
044D: 51 0A    MOV   A,[__r11]          (0031) ENDIF
044F: 08       PUSH  A                  (0032) 
0450: 51 09    MOV   A,[__rX]           (0033) 
0452: 08       PUSH  A                  (0034) ;-----------------------------------------------
0453: 51 08    MOV   A,[__rY]           (0035) ; Variable Allocation
0455: 08       PUSH  A                  (0036) ;-----------------------------------------------
0456: 51 07    MOV   A,[__rZ]           (0037) 
0458: 08       PUSH  A                  (0038) IF (RX8_1_RXBUF_ENABLE)
                                        (0039) AREA InterruptRAM(RAM,REL,CON)
                                        (0040)  RX8_1_fStatus:
                                        (0041) _RX8_1_fStatus:      BLK  1
                                        (0042)  RX8_1_bRxCnt:
                                        (0043) _RX8_1_bRxCnt:       BLK  1
                                        (0044) AREA RX8_1_RAM(RAM,REL,CON)
                                        (0045)  RX8_1_aRxBuffer:    
                                        (0046) _RX8_1_aRxBuffer:    BLK RX8_1_RX_BUFFER_SIZE
                                        (0047) ENDIF
                                        (0048) 
                                        (0049) 
                                        (0050) AREA InterruptRAM(RAM,REL,CON)
                                        (0051) 
                                        (0052) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0053) ;---------------------------------------------------
                                        (0054) ; Insert your custom declarations below this banner
                                        (0055) ;---------------------------------------------------
                                        (0056) 
                                        (0057) ;------------------------
                                        (0058) ; Includes
                                        (0059) ;------------------------
                                        (0060) 
                                        (0061) 	
                                        (0062) ;------------------------
                                        (0063) ;  Constant Definitions
                                        (0064) ;------------------------
                                        (0065) 
                                        (0066) 
                                        (0067) ;------------------------
                                        (0068) ; Variable Allocation
                                        (0069) ;------------------------
                                        (0070) 
                                        (0071) 
                                        (0072) ;---------------------------------------------------
                                        (0073) ; Insert your custom declarations above this banner
                                        (0074) ;---------------------------------------------------
                                        (0075) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0076) 
                                        (0077) 
                                        (0078) AREA UserModules (ROM, REL)
                                        (0079) 
                                        (0080) ;-----------------------------------------------------------------------------
                                        (0081) ;  FUNCTION NAME: _RX8_1_ISR
                                        (0082) ;
                                        (0083) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0084) ;
                                        (0085) ;-----------------------------------------------------------------------------
                                        (0086) ;
                                        (0087) 
                                        (0088) _RX8_1_ISR:
                                        (0089) 
                                        (0090)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ; Insert your custom assembly code below this banner
                                        (0093)    ;---------------------------------------------------
                                        (0094)    ;   NOTE: interrupt service routines must preserve
                                        (0095)    ;   the values of the A and X CPU registers.
                                        (0096)    
                                        (0097)    ;---------------------------------------------------
                                        (0098)    ; Insert your custom assembly code above this banner
                                        (0099)    ;---------------------------------------------------
                                        (0100)    
                                        (0101)    ;---------------------------------------------------
                                        (0102)    ; Insert a lcall to a C function below this banner
                                        (0103)    ; and un-comment the lines between these banners
                                        (0104)    ;---------------------------------------------------
                                        (0105)    
                                        (0106)    PRESERVE_CPU_CONTEXT
0459: 7C 05 8C LCALL _RX8_1_IRQ         (0107)    lcall _RX8_1_IRQ
045C: 18       POP   A                  
045D: 53 07    MOV   [__rZ],A           
045F: 18       POP   A                  
0460: 53 08    MOV   [__rY],A           
0462: 18       POP   A                  
0463: 53 09    MOV   [__rX],A           
0465: 18       POP   A                  
0466: 53 0A    MOV   [__r11],A          
0468: 18       POP   A                  
0469: 53 0B    MOV   [__r10],A          
046B: 18       POP   A                  
046C: 53 0C    MOV   [__r9],A           
046E: 18       POP   A                  
046F: 53 0D    MOV   [__r8],A           
0471: 18       POP   A                  
0472: 53 0E    MOV   [__r7],A           
0474: 18       POP   A                  
0475: 53 0F    MOV   [__r6],A           
0477: 18       POP   A                  
0478: 53 10    MOV   [__r5],A           
047A: 18       POP   A                  
047B: 53 11    MOV   [__r4],A           
047D: 18       POP   A                  
047E: 53 12    MOV   [__r3],A           
0480: 18       POP   A                  
0481: 53 13    MOV   [__r2],A           
0483: 18       POP   A                  
0484: 53 14    MOV   [__r1],A           
0486: 18       POP   A                  
0487: 53 15    MOV   [__r0],A           
0489: 18       POP   A                  
                                        (0108)    RESTORE_CPU_CONTEXT
                                        (0109)    
                                        (0110)    ;---------------------------------------------------
                                        (0111)    ; Insert a lcall to a C function above this banner
                                        (0112)    ; and un-comment the lines between these banners
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0115) 
                                        (0116)  IF (RX8_1_RXBUF_ENABLE)
                                        (0117)    push A
                                        (0118)    push X
                                        (0119) 
                                        (0120)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0121)       REG_PRESERVE IDX_PP                                  ; Save the IDX_PP register	
                                        (0122)    ENDIF
                                        (0123) 
                                        (0124)    mov  X,[RX8_1_bRxCnt]                                   ; Load X with byte counter
                                        (0125)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Read the control register
                                        (0126)    push A                                                  ; Store copy for later test
                                        (0127)                                                            ; IF real RX interrupt
                                        (0128)    and  A,RX8_1_RX_REG_FULL                                ; Did really really get an IRQ
                                        (0129)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
                                        (0130)    pop  A                                                  ; Restore stack
                                        (0131)    jmp  .RESTORE_IDX_PP
                                        (0132) 
                                        (0133) .UARTRX_ReadRx:
                                        (0134) 
                                        (0135)    pop  A                                                  ; Restore status flags
                                        (0136)                                                            ; IF there is no error, get data
                                        (0137)                                                            ; Check for parity or framing error
                                        (0138)    and  A,RX8_1_RX_ERROR
                                        (0139)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
                                        (0140) 
                                        (0141)    or   [RX8_1_fStatus],A                                  ; Set error flags (parity,framing,overrun) bits
                                        (0142) 
                                        (0143)    tst  REG[RX8_1_RX_BUFFER_REG], 0x00                     ; Read the data buffer to clear it.
                                        (0144) 
                                        (0145)    and  A,RX8_1_RX_FRAMING_ERROR                           ; Check for framing error special case
                                        (0146)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
                                        (0147) 
                                        (0148)                                                            ; Disable and re-enable RX to reset after
                                        (0149)                                                            ; framing error.
                                        (0150)    and   REG[RX8_1_CONTROL_REG], ~RX8_1_RX_ENABLE          ; Disable RX
                                        (0151)    or    REG[RX8_1_CONTROL_REG],  RX8_1_RX_ENABLE          ; Enable RX
                                        (0152)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
                                        (0153) 
                                        (0154) 
                                        (0155) .UARTRX_NO_ERROR:
                                        (0156)    mov  A,REG[RX8_1_RX_BUFFER_REG ]                        ; Read the data buffer
                                        (0157) 
                                        (0158)                                                            ; IF buffer not full
                                        (0159)    tst  [RX8_1_fStatus],RX8_1_RX_BUF_CMDTERM               ; Check for buffer full
                                        (0160)    jnz  .RESTORE_IDX_PP                                    ; All done
                                        (0161) 
                                        (0162)    cmp  A,RX8_1_CMD_TERM                                   ; Check for End of command
                                        (0163)    jnz  .UARTRX_CHK_CTLCHAR
                                        (0164)    or   [RX8_1_fStatus],RX8_1_RX_BUF_CMDTERM               ; Set command ready bit
                                        (0165) 
                                        (0166)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer
                                        (0167)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0168)    mov  [X + RX8_1_aRxBuffer],00h                          ; Zero out last data
                                        (0169)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0170)    jmp  .RESTORE_IDX_PP
                                        (0171) 
                                        (0172) .UARTRX_CHK_CTLCHAR:                                       ; Ignore charaters below this value
                                        (0173)                                                            ; If ignore char is set to 0x00, do not
                                        (0174)                                                            ; ignore any characters.
                                        (0175) IF(RX8_1_RX_IGNORE_BELOW)
                                        (0176)    cmp  A,RX8_1_RX_IGNORE_BELOW
                                        (0177)    jc   .RESTORE_IDX_PP
                                        (0178) ENDIF
                                        (0179) 
                                        (0180) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
                                        (0181)    cmp  [RX8_1_bRxCnt],(RX8_1_RX_BUFFER_SIZE - 1)
                                        (0182)    jc   .UARTRX_ISR_GETDATA
                                        (0183)    or   [RX8_1_fStatus],RX8_1_RX_BUF_OVERRUN               ; Set error flags (parity,framing,overrun) bits
                                        (0184) 
                                        (0185)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer             ;   using idexed address mode
                                        (0186)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0187)    mov  [X + RX8_1_aRxBuffer],00h                          ; Zero out last data
                                        (0188)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0189)    jmp  .RESTORE_IDX_PP
                                        (0190) 
                                        (0191)                                                            ; IF input data == "CR", then end of command
                                        (0192) .UARTRX_ISR_GETDATA:
                                        (0193)    inc  X                                                  ; Inc the pointer
                                        (0194)    mov  [RX8_1_bRxCnt],X                                   ; Restore the pointer
                                        (0195)    dec  X                                                  ; Mov X to its original value
                                        (0196) 
                                        (0197)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer             ;   using idexed address mode
                                        (0198)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
                                        (0199)    mov  [X+RX8_1_aRxBuffer],A                              ; store data in array
                                        (0200)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
                                        (0201) 
                                        (0202) 
                                        (0203) .RESTORE_IDX_PP:
                                        (0204)    IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0205)       REG_RESTORE IDX_PP
                                        (0206)    ENDIF
                                        (0207) 
                                        (0208) .END_UARTRX_ISR:
                                        (0209)    pop  X
                                        (0210)    pop  A
                                        (0211) 
                                        (0212) ENDIF
                                        (0213) 
                                        (0214) RX8_1_RX_ISR_END:
048A: 7E       RETI                     (0215)    reti
                                        (0216) 
                                        (0217) 
                                        (0218) ; end of file RX8_1INT.asm
FILE: lib\rx8_1.asm                     (0001) ;;*****************************************************************************
048B: 43 E1 80 OR    REG[0xE1],0x80     (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: RX8_1.asm
                                        (0004) ;;   Version: 3.50, Updated on 2015/3/4 at 22:26:55
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: RX8 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) ;-----------------------------------------------
                                        (0023) ; include instance specific register definitions
                                        (0024) ;-----------------------------------------------
                                        (0025) include "m8c.inc"
                                        (0026) include "memory.inc"
                                        (0027) include "RX8_1.inc"
                                        (0028) 
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Global Symbols
                                        (0032) ;-----------------------------------------------
                                        (0033) export   RX8_1_EnableInt
                                        (0034) export  _RX8_1_EnableInt
                                        (0035) export   RX8_1_DisableInt
                                        (0036) export  _RX8_1_DisableInt
                                        (0037) export   RX8_1_Start
                                        (0038) export  _RX8_1_Start
                                        (0039) export   RX8_1_Stop
                                        (0040) export  _RX8_1_Stop
                                        (0041) export   RX8_1_bReadRxData
                                        (0042) export  _RX8_1_bReadRxData
                                        (0043) export   RX8_1_bReadRxStatus
                                        (0044) export  _RX8_1_bReadRxStatus
                                        (0045) 
                                        (0046) ; Old function name convension, do not use.
                                        (0047) ; These will be removed in a future release.
                                        (0048) export  bRX8_1_ReadRxData
                                        (0049) export _bRX8_1_ReadRxData
                                        (0050) export  bRX8_1_ReadRxStatus
                                        (0051) export _bRX8_1_ReadRxStatus
                                        (0052) 
                                        (0053) ;-----------------------------------------------
                                        (0054) ; High Level RX functions
                                        (0055) ;-----------------------------------------------
                                        (0056) 
                                        (0057) export  RX8_1_cGetChar
                                        (0058) export _RX8_1_cGetChar
                                        (0059) export  RX8_1_cReadChar
                                        (0060) export _RX8_1_cReadChar
                                        (0061) export  RX8_1_iReadChar
                                        (0062) export _RX8_1_iReadChar
                                        (0063) 
                                        (0064) IF (RX8_1_RXBUF_ENABLE)
                                        (0065) export  RX8_1_CmdReset
                                        (0066) export _RX8_1_CmdReset
                                        (0067) export  RX8_1_bCmdCheck
                                        (0068) export _RX8_1_bCmdCheck
                                        (0069) export  RX8_1_bCmdLength
                                        (0070) export _RX8_1_bCmdLength
                                        (0071) export  RX8_1_bErrCheck
                                        (0072) export _RX8_1_bErrCheck
                                        (0073) 
                                        (0074) export  RX8_1_szGetParam
                                        (0075) export _RX8_1_szGetParam
                                        (0076) export  RX8_1_szGetRestOfParams
                                        (0077) export _RX8_1_szGetRestOfParams
                                        (0078) 
                                        (0079) ;-----------------------------------------------
                                        (0080) ;  Variables
                                        (0081) ;-----------------------------------------------
                                        (0082) 
                                        (0083) AREA RX8_1_RAM(RAM,REL,CON)
                                        (0084)  ptrParam:   			BLK  1
                                        (0085) 
                                        (0086) ENDIF
                                        (0087) ;-----------------------------------------------
                                        (0088) ;  EQUATES
                                        (0089) ;-----------------------------------------------
                                        (0090) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0091) 
                                        (0092) area UserModules (ROM, REL)
                                        (0093) 
                                        (0094) .SECTION
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;  FUNCTION NAME: RX8_1_EnableInt
                                        (0097) ;
                                        (0098) ;  DESCRIPTION:
                                        (0099) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                        (0100) ;     bit associated with this User Module. Remember to call the global interrupt
                                        (0101) ;     enable function by using the macro: M8C_EnableGInt.
                                        (0102) ;
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;
                                        (0105) ;  ARGUMENTS: none
                                        (0106) ;
                                        (0107) ;  RETURNS: none
                                        (0108) ;
                                        (0109) ;  SIDE EFFECTS:
                                        (0110) ;    The A and X registers may be modified by this or future implementations
                                        (0111) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0112) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0113) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0114) ;    functions.
                                        (0115) ;
                                        (0116)  RX8_1_EnableInt:
                                        (0117) _RX8_1_EnableInt:
                                        (0118)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0119)    M8C_EnableIntMask RX8_1_INT_REG, RX8_1_bINT_MASK
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_1
048E: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) .SECTION
                                        (0125) ;-----------------------------------------------------------------------------
                                        (0126) ;  FUNCTION NAME: RX8_1_DisableInt
                                        (0127) ;
                                        (0128) ;  DESCRIPTION:
                                        (0129) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                        (0130) ;     associated with this User Module.
                                        (0131) ;
                                        (0132) ;-----------------------------------------------------------------------------
                                        (0133) ;
                                        (0134) ;  ARGUMENTS:  none
                                        (0135) ;
                                        (0136) ;  RETURNS:  none
                                        (0137) ;
                                        (0138) ;  SIDE EFFECTS:
                                        (0139) ;    The A and X registers may be modified by this or future implementations
                                        (0140) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0141) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0142) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0143) ;    functions.
                                        (0144) ;
                                        (0145)  RX8_1_DisableInt:
                                        (0146) _RX8_1_DisableInt:
                                        (0147)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0148)    M8C_DisableIntMask RX8_1_INT_REG, RX8_1_bINT_MASK
                                        (0149)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0150)    ret
                                        (0151) .ENDSECTION
                                        (0152) 
                                        (0153) .SECTION
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: RX8_1_Start(BYTE bParity)
                                        (0156) ;
                                        (0157) ;  DESCRIPTION:
                                        (0158) ;    Sets the start bit and parity in the Control register of this user module.
                                        (0159) ;
                                        (0160) ;-----------------------------------------------------------------------------
                                        (0161) ;
                                        (0162) ;  ARGUMENTS:
                                        (0163) ;    BYTE bParity - parity of received data.  Use defined masks.
                                        (0164) ;    passed in A register.
                                        (0165) ;
                                        (0166) ;  RETURNS: none
                                        (0167) ;
                                        (0168) ;  SIDE EFFECTS:
                                        (0169) ;    The A and X registers may be modified by this or future implementations
                                        (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0173) ;    functions.
                                        (0174) ;
                                        (0175)  RX8_1_Start:
                                        (0176) _RX8_1_Start:
                                        (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
048F: 29 01    OR    A,0x1              (0178)    or    A, bfCONTROL_REG_START_BIT
0491: 60 3F    MOV   REG[0x3F],A        (0179)    mov   REG[RX8_1_CONTROL_REG], A
                                        (0180)    RAM_EPILOGUE RAM_USE_CLASS_1
0493: 7F       RET                      (0181)    ret
                                        (0182) .ENDSECTION
                                        (0183) 
                                        (0184) .SECTION
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;  FUNCTION NAME: RX8_1_Stop
                                        (0187) ;
                                        (0188) ;  DESCRIPTION:
                                        (0189) ;     Disables RX8 operation.
                                        (0190) ;
                                        (0191) ;-----------------------------------------------------------------------------
                                        (0192) ;
                                        (0193) ;  ARGUMENTS: none
                                        (0194) ;
                                        (0195) ;  RETURNS: none
                                        (0196) ;
                                        (0197) ;  SIDE EFFECTS:
                                        (0198) ;    The A and X registers may be modified by this or future implementations
                                        (0199) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0200) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0201) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0202) ;    functions.
                                        (0203) ;
                                        (0204)  RX8_1_Stop:
                                        (0205) _RX8_1_Stop:
                                        (0206)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0207)    and   REG[RX8_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                        (0208)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0209)    ret
                                        (0210) .ENDSECTION
                                        (0211) 
                                        (0212) .SECTION
                                        (0213) ;-----------------------------------------------------------------------------
                                        (0214) ;  FUNCTION NAME: RX8_1_bReadRxData
                                        (0215) ;
                                        (0216) ;  DESCRIPTION:
                                        (0217) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0218) ;     sure data is valid.
                                        (0219) ;
                                        (0220) ;-----------------------------------------------------------------------------
                                        (0221) ;
                                        (0222) ;  ARGUMENTS:  none
                                        (0223) ;
                                        (0224) ;  RETURNS:
                                        (0225) ;    bRxData - returned in A.
                                        (0226) ;
                                        (0227) ;  SIDE EFFECTS:
                                        (0228) ;    The A and X registers may be modified by this or future implementations
                                        (0229) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0230) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0231) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0232) ;    functions.
                                        (0233) ;
                                        (0234)  RX8_1_bReadRxData:
                                        (0235) _RX8_1_bReadRxData:
                                        (0236)  bRX8_1_ReadRxData:
                                        (0237) _bRX8_1_ReadRxData:
                                        (0238)    RAM_PROLOGUE RAM_USE_CLASS_1
0494: 5D 3E    MOV   A,REG[0x3E]        (0239)    mov A, REG[RX8_1_RX_BUFFER_REG]
                                        (0240)    RAM_EPILOGUE RAM_USE_CLASS_1
0496: 7F       RET                      (0241)    ret
                                        (0242) .ENDSECTION
                                        (0243) 
                                        (0244) .SECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: RX8_1_bReadRxStatus
                                        (0247) ;
                                        (0248) ;  DESCRIPTION:
                                        (0249) ;    Reads the RX Status bits in the Control/Status register.
                                        (0250) ;
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;
                                        (0253) ;  ARGUMENTS:  none
                                        (0254) ;
                                        (0255) ;  RETURNS:
                                        (0256) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                        (0257) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0258) ;
                                        (0259) ;  SIDE EFFECTS:
                                        (0260) ;    The A and X registers may be modified by this or future implementations
                                        (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0264) ;    functions.
                                        (0265) ;
                                        (0266)  RX8_1_bReadRxStatus:
                                        (0267) _RX8_1_bReadRxStatus:
                                        (0268)  bRX8_1_ReadRxStatus:
                                        (0269) _bRX8_1_ReadRxStatus:
                                        (0270)    RAM_PROLOGUE RAM_USE_CLASS_1
0497: 5D 3F    MOV   A,REG[0x3F]        (0271)    mov A,  REG[RX8_1_CONTROL_REG]
                                        (0272)    RAM_EPILOGUE RAM_USE_CLASS_1
0499: 7F       RET                      (0273)    ret
                                        (0274) .ENDSECTION
                                        (0275) 
                                        (0276) ;-----------------------------------------------
                                        (0277) ; High Level RX functions
                                        (0278) ;-----------------------------------------------
                                        (0279) 
                                        (0280) .SECTION
                                        (0281) ;-----------------------------------------------------------------------------
                                        (0282) ;  FUNCTION NAME: RX8_1_cGetChar
                                        (0283) ;
                                        (0284) ;  DESCRIPTION:
                                        (0285) ;     Read character from UART RX port.
                                        (0286) ;
                                        (0287) ;
                                        (0288) ;  ARGUMENTS:
                                        (0289) ;      none
                                        (0290) ;
                                        (0291) ;  RETURNS:
                                        (0292) ;     char that is returned from UART
                                        (0293) ;
                                        (0294) ;  SIDE EFFECTS:
                                        (0295) ;    The A and X registers may be modified by this or future implementations
                                        (0296) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0297) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0298) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0299) ;    functions.
                                        (0300) ;    
                                        (0301) ;    Program flow will stay in this function until a character is received.
                                        (0302) ;    If the watchdog timer is used, care must be taken to make sure that
                                        (0303) ;    the delay between characters is less than the watchdog timeout.
                                        (0304) ;
                                        (0305)  RX8_1_cGetChar:
                                        (0306) _RX8_1_cGetChar:
                                        (0307)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0308) 
                                        (0309) .getChar_Loop:
049A: 49 3F 08 TST   REG[0x3F],0x8      (0310)    tst REG[RX8_1_CONTROL_REG],RX8_1_RX_REG_FULL  ; Check if a character is ready
049D: AF FC    JZ    _RX8_1_cGetChar    (0311)    jz  .getChar_Loop                                        ; If not loop
                                        (0312) 
049F: 5D 3E    MOV   A,REG[0x3E]        (0313)    mov A, REG[RX8_1_RX_BUFFER_REG]               ; Get character
                                        (0314)    RAM_EPILOGUE RAM_USE_CLASS_1
04A1: 7F       RET                      (0315)    ret
                                        (0316) .ENDSECTION
                                        (0317) 
                                        (0318) .SECTION
                                        (0319) ;-----------------------------------------------------------------------------
                                        (0320) ;  FUNCTION NAME: RX8_1_cReadChar
                                        (0321) ;
                                        (0322) ;  DESCRIPTION:
                                        (0323) ;     Read character from UART RX port.
                                        (0324) ;
                                        (0325) ;  ARGUMENTS:
                                        (0326) ;      none
                                        (0327) ;
                                        (0328) ;  RETURNS:
                                        (0329) ;     char that is returned from UART
                                        (0330) ;
                                        (0331) ;  SIDE EFFECTS:
                                        (0332) ;    The A and X registers may be modified by this or future implementations
                                        (0333) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0334) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0335) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0336) ;    functions.
                                        (0337) ;
                                        (0338) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                        (0339) ;    implies a valid character or an error condition occured.
                                        (0340) ;
                                        (0341)  RX8_1_cReadChar:
                                        (0342) _RX8_1_cReadChar:
                                        (0343)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0344) 
                                        (0345)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Get Status of RX
                                        (0346)    push A
                                        (0347)    and  A,RX8_1_RX_COMPLETE                                ; Check if a character is ready
                                        (0348)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
                                        (0349)    pop  A
                                        (0350)    jmp  .RX_NO_VALID_CHAR
                                        (0351) 
                                        (0352) .RX_DATA_RDY:
                                        (0353)    mov  A,REG[RX8_1_RX_BUFFER_REG]                         ; Read data first, then
                                        (0354)    swap A,X                                                ; determine if data is valid
                                        (0355) 
                                        (0356)    pop  A                                                  ; Check for errors
                                        (0357)    and  A,(RX8_1_RX_PARITY_ERROR | RX8_1_RX_FRAMING_ERROR)
                                        (0358)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                        (0359)    swap A,X                                                ; Put data in A and exit
                                        (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0361)    ret
                                        (0362) 
                                        (0363) .RX_NO_VALID_CHAR:
                                        (0364)    mov A,0x00                                              ; Zero out character
                                        (0365) 
                                        (0366)  End_RX8_1_cReadChar:
                                        (0367)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0368)    ret
                                        (0369) .ENDSECTION
                                        (0370) 																			
                                        (0371) .SECTION
                                        (0372) ;-----------------------------------------------------------------------------
                                        (0373) ;  FUNCTION NAME: RX8_1_iReadChar
                                        (0374) ;
                                        (0375) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                        (0376) ; to just set a value in the upper byte if error conditions exists.
                                        (0377) ;
                                        (0378) ;  DESCRIPTION:
                                        (0379) ;     Read character from UART RX port.
                                        (0380) ;
                                        (0381) ;  ARGUMENTS:
                                        (0382) ;      none
                                        (0383) ;
                                        (0384) ;  RETURNS:
                                        (0385) ;     An integer value is returned.  A negative value inplies and error
                                        (0386) ;     condition, a positive value between 0 and 255 is the return character.
                                        (0387) ;
                                        (0388) ;     Error Codes:
                                        (0389) ;        0x80CC    Parity Error
                                        (0390) ;        0x40CC    Overrun Error
                                        (0391) ;        0x20CC    Framing Error
                                        (0392) ;        0x01CC    No Data available
                                        (0393) ;
                                        (0394) ;  SIDE EFFECTS:
                                        (0395) ;    The A and X registers may be modified by this or future implementations
                                        (0396) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0397) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0398) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0399) ;    functions.
                                        (0400) ;
                                        (0401)  RX8_1_iReadChar:
                                        (0402) _RX8_1_iReadChar:
                                        (0403)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0404) 
                                        (0405)    mov  A,REG[RX8_1_CONTROL_REG]                           ; Get Status of RX
                                        (0406)                                                            ; Mask only errors and data ready
                                        (0407)    and  A,(RX8_1_RX_ERROR|RX8_1_RX_REG_FULL)
                                        (0408)    push A
                                        (0409)    and  A,RX8_1_RX_COMPLETE                                ; Check if a character is ready
                                        (0410)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                        (0411)    pop  A
                                        (0412)    or   A,RX8_1_RX_NO_DATA                                 ; Add no data flag
                                        (0413)    swap A,X
                                        (0414)    jmp  End_RX8_1_iReadChar
                                        (0415) 
                                        (0416) .RX_GET_DATA:
                                        (0417)    pop  A
                                        (0418)    and  A,RX8_1_RX_ERROR
                                        (0419)    swap A,X
                                        (0420)    mov  A,REG[RX8_1_RX_BUFFER_REG]                         ; Read data first, then
                                        (0421)                                                            ; determine if data is valid
                                        (0422) 
                                        (0423)  End_RX8_1_iReadChar:
                                        (0424)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0425)    ret
                                        (0426) .ENDSECTION
                                        (0427) 
                                        (0428) 
                                        (0429) 
                                        (0430) IF (RX8_1_RXBUF_ENABLE)
                                        (0431) .SECTION
                                        (0432) ;-----------------------------------------------------------------------------
                                        (0433) ;-----------------------------------------------------------------------------
                                        (0434) ;
                                        (0435) ;     Command Buffer commands
                                        (0436) ;
                                        (0437) ;-----------------------------------------------------------------------------
                                        (0438) ;-----------------------------------------------------------------------------
                                        (0439) 
                                        (0440) ;-----------------------------------------------------------------------------
                                        (0441) ;  FUNCTION NAME: RX8_1_CmdReset
                                        (0442) ;
                                        (0443) ;  DESCRIPTION:
                                        (0444) ;     Reset command string and status flags
                                        (0445) ;
                                        (0446) ;  ARGUMENTS:
                                        (0447) ;     none.
                                        (0448) ;
                                        (0449) ;  RETURNS:
                                        (0450) ;     none.
                                        (0451) ;
                                        (0452) ;  SIDE EFFECTS:
                                        (0453) ;    The A and X registers may be modified by this or future implementations
                                        (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0457) ;    functions.
                                        (0458) ;          
                                        (0459) ;    Currently only the page pointer registers listed below are modified: 
                                        (0460) ;          CUR_PP
                                        (0461) ;
                                        (0462) ;  THEORY of OPERATION or PROCEDURE:
                                        (0463) ;     Clear the command buffer, command counter, and flag.
                                        (0464) ;
                                        (0465)  RX8_1_CmdReset:
                                        (0466) _RX8_1_CmdReset:
                                        (0467)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0468)    RAM_SETPAGE_CUR >RX8_1_aRxBuffer
                                        (0469)    mov [RX8_1_aRxBuffer], 0x00
                                        (0470)    RAM_SETPAGE_CUR >ptrParam
                                        (0471)    mov [ptrParam],0x00
                                        (0472)    RAM_SETPAGE_CUR >RX8_1_bRxCnt
                                        (0473)    mov [RX8_1_bRxCnt], 0x00
                                        (0474)    and [RX8_1_fStatus], 0x00
                                        (0475)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0476)    ret
                                        (0477) .ENDSECTION
                                        (0478) 
                                        (0479) .SECTION
                                        (0480) ;-----------------------------------------------------------------------------
                                        (0481) ;  FUNCTION NAME: RX8_1_bCmdCheck
                                        (0482) ;
                                        (0483) ;  DESCRIPTION:
                                        (0484) ;     Check to see if valid command in buffer.
                                        (0485) ;
                                        (0486) ;  ARGUMENTS:
                                        (0487) ;     none.
                                        (0488) ;
                                        (0489) ;  RETURNS:
                                        (0490) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0491) ;                     Returns non-zero value in A if command is valid.
                                        (0492) ;
                                        (0493) ;  SIDE EFFECTS:
                                        (0494) ;    The A and X registers may be modified by this or future implementations
                                        (0495) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0496) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0497) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0498) ;    functions.
                                        (0499) ;          
                                        (0500) ;    Currently only the page pointer registers listed below are modified: 
                                        (0501) ;          CUR_PP
                                        (0502) ;
                                        (0503) ;  THEORY of OPERATION or PROCEDURE:
                                        (0504) ;     Read the status and control register.
                                        (0505) ;
                                        (0506)  RX8_1_bCmdCheck:
                                        (0507) _RX8_1_bCmdCheck:
                                        (0508)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0509)    RAM_SETPAGE_CUR >RX8_1_fStatus
                                        (0510)    mov A,  [RX8_1_fStatus]
                                        (0511)    and A, RX8_1_RX_BUF_CMDTERM                   ; Mask off Command status
                                        (0512)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0513)    ret
                                        (0514) .ENDSECTION
                                        (0515) 
                                        (0516) .SECTION
                                        (0517) ;-----------------------------------------------------------------------------
                                        (0518) ;  FUNCTION NAME: RX8_1_bErrCheck
                                        (0519) ;
                                        (0520) ;  DESCRIPTION:
                                        (0521) ;     Check to see if an error has occured since last CmdReset
                                        (0522) ;
                                        (0523) ;  ARGUMENTS:
                                        (0524) ;     none.
                                        (0525) ;
                                        (0526) ;  RETURNS:
                                        (0527) ;     BYTE  fStatus - Status of command receive buffer.
                                        (0528) ;                     Returns non-zero value in A if command is valid.
                                        (0529) ;           0x80 => Parity Error
                                        (0530) ;           0x40 => OverRun Error
                                        (0531) ;           0x20 => Framing Error
                                        (0532) ;           0x10 => Software Buffer OverRun
                                        (0533) ;
                                        (0534) ;  SIDE EFFECTS:
                                        (0535) ;    The A and X registers may be modified by this or future implementations
                                        (0536) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0537) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0538) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0539) ;    functions.
                                        (0540) ;          
                                        (0541) ;    Currently only the page pointer registers listed below are modified: 
                                        (0542) ;          CUR_PP
                                        (0543) ;
                                        (0544) ;     Error Status is clear when read.
                                        (0545) ;
                                        (0546) ;  THEORY of OPERATION or PROCEDURE:
                                        (0547) ;     Read RX buffer error status and clear status
                                        (0548) ;
                                        (0549)  RX8_1_bErrCheck:
                                        (0550) _RX8_1_bErrCheck:
                                        (0551)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0552)    RAM_SETPAGE_CUR >RX8_1_fStatus
                                        (0553)    mov A,  [RX8_1_fStatus]
                                        (0554)    and A, RX8_1_RX_BUF_ERROR                     ; Mask off Error status
                                        (0555)    and [RX8_1_fStatus], ~RX8_1_RX_BUF_ERROR
                                        (0556)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0557)    ret
                                        (0558) .ENDSECTION
                                        (0559) 
                                        (0560) .SECTION
                                        (0561) ;-----------------------------------------------------------------------------
                                        (0562) ;  FUNCTION NAME: RX8_1_bCmdLength
                                        (0563) ;
                                        (0564) ;  DESCRIPTION:
                                        (0565) ;     Get length of command string
                                        (0566) ;
                                        (0567) ;  ARGUMENTS:
                                        (0568) ;     none.
                                        (0569) ;
                                        (0570) ;  RETURNS:
                                        (0571) ;     BYTE  bRxCnt    Returns the command length in A.
                                        (0572) ;
                                        (0573) ;  SIDE EFFECTS:
                                        (0574) ;    The A and X registers may be modified by this or future implementations
                                        (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0578) ;    functions.
                                        (0579) ;          
                                        (0580) ;    Currently only the page pointer registers listed below are modified: 
                                        (0581) ;          CUR_PP
                                        (0582) ;
                                        (0583)  RX8_1_bCmdLength:
                                        (0584) _RX8_1_bCmdLength:
                                        (0585)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0586)    RAM_SETPAGE_CUR >RX8_1_bRxCnt
                                        (0587)    mov A,  [RX8_1_bRxCnt]
                                        (0588)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0589)    ret
                                        (0590) .ENDSECTION
                                        (0591) 
                                        (0592) .SECTION
                                        (0593) ;-----------------------------------------------------------------------------
                                        (0594) ;  FUNCTION NAME: RX8_1_szGetParam
                                        (0595) ;
                                        (0596) ;  DESCRIPTION:
                                        (0597) ;      Return next parameter from UART Rx buffer
                                        (0598) ;
                                        (0599) ;
                                        (0600) ;  ARGUMENTS:  none
                                        (0601) ;
                                        (0602) ;  RETURNS:
                                        (0603) ;     A => MSB of parameter address
                                        (0604) ;     X => LSB of parameter address
                                        (0605) ;
                                        (0606) ;  SIDE EFFECTS:
                                        (0607) ;    The A and X registers may be modified by this or future implementations
                                        (0608) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0609) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0610) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0611) ;    functions.
                                        (0612) ;          
                                        (0613) ;    Currently only the page pointer registers listed below are modified:
                                        (0614) ;          CUR_PP
                                        (0615) ;          IDX_PP
                                        (0616) ;
                                        (0617) ;     The receive string is modified by placing Null characters at the end
                                        (0618) ;     of each parameter as they are recovered.
                                        (0619) ;
                                        (0620) ;  THEORY OF OPERATION:
                                        (0621) ;     This function is a stateful generator of addresses to the "parameters"
                                        (0622) ;     of an input "Command". It scans the (optional) input buffer and breaks
                                        (0623) ;     each lexically distinct element into a null-terminated string by replacing
                                        (0624) ;     delimiters with nulls, as appropriate. The state of the generator is 
                                        (0625) ;     maintained by the private variable ptrParam, which is a buffer-relative
                                        (0626) ;     offset. The generator is initialized by a call to the function
                                        (0627) ;     RX8_1_CmdReset which resets the entire buffer to the 'empty'
                                        (0628) ;     state. Typically this function, RX8_1_szGetParam, is
                                        (0629) ;     not called until the buffer has been loaded with an entire command
                                        (0630) ;     (See RX8_1_bCmdCheck).
                                        (0631) ;
                                        (0632) ;     Note, there is no special distinction between the "command" and the 
                                        (0633) ;     "parameters". The first non-delimiter character of the buffer---the first
                                        (0634) ;     character of the "command"---is also, for the purposes of this function,
                                        (0635) ;     the first "parameter" to which it returns an address.
                                        (0636) ;
                                        (0637) ;     The value of a delimiter (commonly an ascii space, 0x20 and decimal 32)
                                        (0638) ;     is determined at configuration time by a user module parameter.
                                        (0639) ;
                                        (0640)  RX8_1_szGetParam:
                                        (0641) _RX8_1_szGetParam:
                                        (0642)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0643)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0644)    RAM_SETPAGE_CUR >ptrParam
                                        (0645)    RAM_SETPAGE_IDX >RX8_1_aRxBuffer
                                        (0646) 
                                        (0647)    mov  A, <RX8_1_aRxBuffer                 ; Get address to receive buffer
                                        (0648)    add  A, [ptrParam]                      ; Add string offset
                                        (0649)    mov  X,A
                                        (0650) 
                                        (0651)    mov  A,[X]                              ; Get character pointed by X
                                        (0652)    jnz  .CheckForDelim                     ; Check for Null character
                                        (0653)    push X                                  ; Save LSB of current pointer
                                        (0654)    jmp  .End_GetNextParam
                                        (0655) 
                                        (0656)                                             ; Check for delimiter and keep looping until
                                        (0657)                                             ; all leading delimiters have been found.
                                        (0658) .CheckForDelim:
                                        (0659)     cmp  A,RX8_1_DELIMITER                  ; Check if we have a delimiter
                                        (0660)     jnz  .ParamStartFound
                                        (0661)     inc  X                                  ; Increment both current pointer and
                                        (0662)     inc  [ptrParam]                         ; stored pointer.
                                        (0663)     mov  A,[X]                              ; Get character pointed by X
                                        (0664)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0665)     jnz  .CheckForDelim
                                        (0666)                                             ; End of string found
                                        (0667) .EndOfString:
                                        (0668)     push X                                  ; Save ptr
                                        (0669) .TerminateString:
                                        (0670)     mov  [X],0x00                           ; Make sure string is zero
                                        (0671)     jmp  .End_GetNextParam
                                        (0672) 
                                        (0673) .ParamStartFound:
                                        (0674)     push X                                  ; Beginning of parameter found, save pointer
                                        (0675) 
                                        (0676) .ParamLoop:
                                        (0677)                                             ; Now loop until end of parameter found.
                                        (0678)     inc  X                                  ; Advance pointers.
                                        (0679)     inc  [ptrParam]
                                        (0680)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0681)     jz   .TerminateString
                                        (0682)     mov  A,[X]                              ; Get next character
                                        (0683)     jz   .End_GetNextParam
                                        (0684)     cmp  A,RX8_1_DELIMITER                  ; Check if we have a delimiter
                                        (0685)     jnz  .ParamLoop                         ; Still no delimiter, loop again
                                        (0686) 
                                        (0687)     mov  [X],0x00                           ; Replace delimiter with null for end of substring
                                        (0688)     inc  [ptrParam]
                                        (0689)     cmp  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Check if we are at the end of buffer
                                        (0690)     jnz  .End_GetNextParam                  ; If not end of string leave
                                        (0691)     mov  [ptrParam],(RX8_1_RX_BUFFER_SIZE -1)  ; Reset pointer to end of string.
                                        (0692) 
                                        (0693) 
                                        (0694) .End_GetNextParam:
                                        (0695)    pop  X
                                        (0696)    push X
                                        (0697)    cmp  [X],0x00
                                        (0698)    jnz  .NotNullString
                                        (0699)    pop  X
                                        (0700)    mov  X,0x00
                                        (0701)    mov  A,X
                                        (0702)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0703)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0704)    ret
                                        (0705) 
                                        (0706) .NotNullString:
                                        (0707)    pop  X
                                        (0708)    mov  A,>RX8_1_aRxBuffer                     ; Return pointer
                                        (0709)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0710)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0711)    ret
                                        (0712) .ENDSECTION
                                        (0713) 
                                        (0714) .SECTION
                                        (0715) ;-----------------------------------------------------------------------------
                                        (0716) ;  FUNCTION NAME: RX8_1_szGetRestOfParams
                                        (0717) ;
                                        (0718) ;  DESCRIPTION:
                                        (0719) ;      Return the rest of the UART RX buffer
                                        (0720) ;
                                        (0721) ;
                                        (0722) ;  ARGUMENTS:  none
                                        (0723) ;
                                        (0724) ;  RETURNS:
                                        (0725) ;     A => MSB of parameter
                                        (0726) ;     X => LSB of parameter
                                        (0727) ;
                                        (0728) ;  SIDE EFFECTS:
                                        (0729) ;    The A and X registers may be modified by this or future implementations
                                        (0730) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0731) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0732) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0733) ;    functions.
                                        (0734) ;          
                                        (0735) ;    Currently only the page pointer registers listed below are modified: 
                                        (0736) ;          CUR_PP
                                        (0737) ;
                                        (0738)  RX8_1_szGetRestOfParams:
                                        (0739) _RX8_1_szGetRestOfParams:
                                        (0740)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0741)    RAM_SETPAGE_CUR >ptrParam
                                        (0742) 
                                        (0743)     mov  A, <RX8_1_aRxBuffer                ; Get address to receive buffer
                                        (0744)     add  A, [ptrParam]                      ; Add string offset
                                        (0745)     mov  X,A
                                        (0746)     mov  A,>RX8_1_aRxBuffer                 ; Return pointer
                                        (0747) 
                                        (0748)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0749)     ret
                                        (0750) .ENDSECTION
                                        (0751) 
                                        (0752) ENDIF
                                        (0753) ; End of File RX8_1.asm
FILE: lib\led_fix.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LED_FIX.asm
                                        (0004) ;;  Version: 2.00, Updated on 2015/3/4 at 22:26:37
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LED user module.
                                        (0008) ;;
                                        (0009) ;;
                                        (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0012) ;;        This means it is the caller's responsibility to preserve any values
                                        (0013) ;;        in the X and A registers that are still needed after the API functions
                                        (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0018) ;;-----------------------------------------------------------------------------
                                        (0019) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0020) ;;*****************************************************************************
                                        (0021) ;;*****************************************************************************
                                        (0022) 
                                        (0023) include "LED_FIX.inc"
                                        (0024) include "memory.inc"
                                        (0025) 
                                        (0026) export _LED_FIX_Start
                                        (0027) export  LED_FIX_Start
                                        (0028) 
                                        (0029) export _LED_FIX_Stop
                                        (0030) export  LED_FIX_Stop
                                        (0031) 
                                        (0032) export _LED_FIX_On
                                        (0033) export  LED_FIX_On
                                        (0034) 
                                        (0035) export _LED_FIX_Off
                                        (0036) export  LED_FIX_Off
                                        (0037) 
                                        (0038) export _LED_FIX_Switch
                                        (0039) export  LED_FIX_Switch
                                        (0040) 
                                        (0041) export _LED_FIX_Invert
                                        (0042) export  LED_FIX_Invert
                                        (0043) 
                                        (0044) export _LED_FIX_GetState
                                        (0045) export  LED_FIX_GetState
                                        (0046) 
                                        (0047) 
                                        (0048) AREA UserModules (ROM, REL)
                                        (0049) 
                                        (0050) 
                                        (0051) .SECTION
                                        (0052) ;-----------------------------------------------------------------------------
                                        (0053) ;  FUNCTION NAME: LED_FIX_Start(void)
                                        (0054) ;  FUNCTION NAME: LED_FIX_Stop(void)
                                        (0055) ;
                                        (0056) ;  FUNCTION NAME: LED_FIX_Switch(void)
                                        (0057) ;
                                        (0058) ;  DESCRIPTION: ( Switch )
                                        (0059) ;     Turn LED on or off     
                                        (0060) ;
                                        (0061) ;  DESCRIPTION: ( Start, Stop )
                                        (0062) ;     Turn LED off                       
                                        (0063) ;
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ;
                                        (0066) ;  ARGUMENTS:  ( Switch )
                                        (0067) ;     A => If 0, turn off LED, if > 0 turn on LED
                                        (0068) ;
                                        (0069) ;  ARGUMENTS:  ( Start, Stop )
                                        (0070) ;      None
                                        (0071) ;
                                        (0072) ;  RETURNS:  none
                                        (0073) ;
                                        (0074) ;  SIDE EFFECTS:
                                        (0075) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0076) ;
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) _LED_FIX_On:
                                        (0079)  LED_FIX_On:
04A2: 50 01    MOV   A,0x1              (0080)    mov  A,0x01
04A4: 80 03    JMP   _LED_FIX_Switch    (0081)    jmp  LED_FIX_Switch 
                                        (0082) 
                                        (0083) _LED_FIX_Start:
                                        (0084)  LED_FIX_Start:
                                        (0085) _LED_FIX_Stop:
                                        (0086)  LED_FIX_Stop:
                                        (0087) _LED_FIX_Off:
                                        (0088)  LED_FIX_Off:
04A6: 50 00    MOV   A,0x0              (0089)    mov  A,0x00
                                        (0090) 
                                        (0091) _LED_FIX_Switch:
                                        (0092)  LED_FIX_Switch:
                                        (0093)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0094)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0095)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0096) 
04A8: 29 00    OR    A,0x0              (0097)    or   A,0x00                                   ; Check mode
04AA: A0 06    JZ    0x04B1             (0098)    jz   .Turn_Off_LED
                                        (0099) 
                                        (0100) .Turn_On_LED:
                                        (0101) IF(0)                                            ; Active High Digit Drive
                                        (0102)    or   [Port_0_Data_SHADE],LED_FIX_PinMask
                                        (0103) ELSE                                             ; Active Low Digit Drive
04AC: 26 16 F7 AND   [0x16],0xF7        (0104)    and  [Port_0_Data_SHADE],~LED_FIX_PinMask
                                        (0105) ENDIF
04AF: 80 04    JMP   0x04B4             (0106)    jmp  .Switch_LED
                                        (0107) 
                                        (0108) .Turn_Off_LED:
                                        (0109) IF(0)                      ; Active High Digit Drive
                                        (0110)    and  [Port_0_Data_SHADE],~LED_FIX_PinMask
                                        (0111) ELSE                              ; Active Low Digit Drive
04B1: 2E 16 08 OR    [0x16],0x8         (0112)    or   [Port_0_Data_SHADE],LED_FIX_PinMask
                                        (0113) ENDIF
                                        (0114) 
                                        (0115) .Switch_LED:
04B4: 51 16    MOV   A,[0x16]           (0116)    mov  A,[Port_0_Data_SHADE]
04B6: 60 00    MOV   REG[0x0],A         (0117)    mov  reg[LED_FIX_PortDR],A
                                        (0118) 
                                        (0119)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0120)    RAM_EPILOGUE RAM_USE_CLASS_4
04B8: 7F       RET                      (0121)    ret
                                        (0122) .ENDSECTION
                                        (0123) 
                                        (0124) 
                                        (0125) 
                                        (0126) .SECTION
                                        (0127) ;-----------------------------------------------------------------------------
                                        (0128) ;  FUNCTION NAME: LED_FIX_Invert(void)
                                        (0129) ;
                                        (0130) ;  DESCRIPTION:
                                        (0131) ;     Invert state of LED                               
                                        (0132) ;
                                        (0133) ;-----------------------------------------------------------------------------
                                        (0134) ;
                                        (0135) ;  ARGUMENTS: none
                                        (0136) ;
                                        (0137) ;  RETURNS:  none
                                        (0138) ;
                                        (0139) ;  SIDE EFFECTS:
                                        (0140) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0141) ;
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) _LED_FIX_Invert:
                                        (0144)  LED_FIX_Invert:
                                        (0145)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0146)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0147)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0148) 
                                        (0149)    xor  [Port_0_Data_SHADE],LED_FIX_PinMask
                                        (0150)    mov  A,[Port_0_Data_SHADE]
                                        (0151)    mov  reg[LED_FIX_PortDR],A
                                        (0152) 
                                        (0153)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0154)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0155)    ret
                                        (0156) .ENDSECTION
                                        (0157) 
                                        (0158) .SECTION
                                        (0159) ;-----------------------------------------------------------------------------
                                        (0160) ;  FUNCTION NAME: LED_FIX_GetState(void)
                                        (0161) ;
                                        (0162) ;  DESCRIPTION:
                                        (0163) ;     Get state of LED
                                        (0164) ;
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;
                                        (0167) ;  ARGUMENTS: none
                                        (0168) ;
                                        (0169) ;  RETURNS:  
                                        (0170) ;    State of LED   1 = ON,  0 = OFF
                                        (0171) ;
                                        (0172) ;  SIDE EFFECTS:
                                        (0173) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0174) ;
                                        (0175) ;-----------------------------------------------------------------------------
                                        (0176) _LED_FIX_GetState:
                                        (0177)  LED_FIX_GetState:
                                        (0178)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0179)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0180)    RAM_SETPAGE_CUR >Port_0_Data_SHADE
                                        (0181) 
                                        (0182)    mov   A,[Port_0_Data_SHADE]         ; Get shade value
                                        (0183) IF(0)                                  ; Active High Digit Drive
                                        (0184)    // Nothing for now
                                        (0185) ELSE                                   ; Active Low Digit Drive
                                        (0186)    cpl   A                             ; Invert bit if Active low
                                        (0187) ENDIF
                                        (0188)    and   A,LED_FIX_PinMask             ; Mask off the trash
                                        (0189)    jz    .End_LED_GS                   ; If zero, we're done
                                        (0190)    mov   A,0x01                        ; Return a 1 no mater what the mask is.
                                        (0191) 
                                        (0192) .End_LED_GS:
                                        (0193)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0194)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0195)    ret
                                        (0196) .ENDSECTION
FILE: C:\Users\MAB0B~1.SAN\Desktop\GPSMux\GPSSWI~1\GPSSWI~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>        // part specific constants and macros
(0006) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0007) 
(0008) #include "queue.h"
(0009) 
(0010) #define NO_FIX				0
(0011) #define FIX0				1
(0012) #define FIX1				2
(0013) #define FIX2				3
(0014) 
(0015) #define IDLE				0
(0016) #define	SENTENCE			1
(0017) #define SFIX				2
(0018) 
(0019) #define SoM					'$'
(0020) #define GGA_PREFIX			"GPGGA"
(0021) 
(0022) #define FIX_POSITION		5	// Six commas minus 1 due to parser structure
(0023) #define FIX_POSITION_MARK	','
(0024) 
(0025) typedef struct {
(0026) 	BYTE fix_status;
(0027) 	BYTE parse_status;
(0028) 	BYTE idx;
(0029) } GPSStatus;
(0030) 
(0031) BOOL TX8_TX_Pending = FALSE;
(0032) 
(0033) GPSStatus gps1 = { NO_FIX, IDLE, 0 };
(0034) GPSStatus gps2 = { NO_FIX, IDLE, 0 };
(0035) 
(0036) Queue queue;
(0037) 
(0038) void parse(char c, GPSStatus* gps)
(0039) {
LED_FIX_Invert|LED_FIX_GetState|__UserModules_end|_parse|__text_start|_parse:
  gps                  --> X-6
  c                    --> X-4
    04B9: 10       PUSH  X
    04BA: 4F       MOV   X,SP
    04BB: 38 02    ADD   SP,0x2
(0040) 	// TODO: TODO add support for GPGSA sentence
(0041) 	switch (gps->parse_status)
    04BD: 52 FB    MOV   A,[X-5]
    04BF: 01 01    ADD   A,0x1
    04C1: 53 14    MOV   [__r1],A
    04C3: 3E 14    MVI   A,[__r1]
    04C5: 54 01    MOV   [X+1],A
    04C7: 56 00 00 MOV   [X+0],0x0
    04CA: 3D 00 00 CMP   [X+0],0x0
    04CD: B0 06    JNZ   0x04D4
    04CF: 3D 01 00 CMP   [X+1],0x0
    04D2: A0 17    JZ    0x04EA
    04D4: 3D 00 00 CMP   [X+0],0x0
    04D7: B0 06    JNZ   0x04DE
    04D9: 3D 01 01 CMP   [X+1],0x1
    04DC: A0 22    JZ    0x04FF
    04DE: 3D 00 00 CMP   [X+0],0x0
    04E1: B0 06    JNZ   0x04E8
    04E3: 3D 01 02 CMP   [X+1],0x2
    04E6: A0 68    JZ    0x054F
    04E8: 80 9B    JMP   0x0584
(0042) 	{
(0043) 		case IDLE:
(0044) 			if (c == SoM) {
    04EA: 3D FC 24 CMP   [X-4],0x24
    04ED: B0 9A    JNZ   0x0588
(0045) 				gps->parse_status = SENTENCE;
    04EF: 52 FB    MOV   A,[X-5]
    04F1: 01 01    ADD   A,0x1
    04F3: 53 14    MOV   [__r1],A
    04F5: 50 01    MOV   A,0x1
    04F7: 3F 14    MVI   [__r1],A
(0046) 				gps->idx = 0;
    04F9: 52 FB    MOV   A,[X-5]
    04FB: 92 6F    CALL  0x076C
(0047) 			}
(0048) 			break;
    04FD: 80 8A    JMP   0x0588
(0049) 
(0050) 		case SENTENCE:
(0051) 			if ((gps->idx < (sizeof(GGA_PREFIX)-1)) && (c == GGA_PREFIX[gps->idx]))
    04FF: 92 51    CALL  0x0752
    0501: 53 14    MOV   [__r1],A
    0503: 55 15 00 MOV   [__r0],0x0
    0506: 11 05    SUB   A,0x5
    0508: 50 00    MOV   A,0x0
    050A: 19 00    SBB   A,0x0
    050C: D0 26    JNC   0x0533
    050E: 06 14 5C ADD   [__r1],0x5C
    0511: 0E 15 01 ADC   [__r0],0x1
    0514: 51 15    MOV   A,[__r0]
    0516: 10       PUSH  X
    0517: 58 14    MOV   X,[__r1]
    0519: 28       ROMX  
    051A: 20       POP   X
    051B: 53 15    MOV   [__r0],A
    051D: 52 FC    MOV   A,[X-4]
    051F: 3A 15    CMP   A,[__r0]
    0521: B0 11    JNZ   0x0533
(0052) 				gps->idx++;
    0523: 52 FB    MOV   A,[X-5]
    0525: 01 02    ADD   A,0x2
    0527: 53 14    MOV   [__r1],A
    0529: 52 FA    MOV   A,[X-6]
    052B: 09 00    ADC   A,0x0
    052D: 53 15    MOV   [__r0],A
    052F: 92 44    CALL  0x0775
    0531: 80 56    JMP   0x0588
(0053) 			else if (gps->idx == (sizeof (GGA_PREFIX)-1)) {
    0533: 92 1D    CALL  0x0752
    0535: 39 05    CMP   A,0x5
    0537: B0 11    JNZ   0x0549
(0054) 				gps->idx = 0;
    0539: 52 FB    MOV   A,[X-5]
    053B: 92 2F    CALL  0x076C
(0055) 				gps->parse_status = SFIX;
    053D: 52 FB    MOV   A,[X-5]
    053F: 01 01    ADD   A,0x1
    0541: 53 14    MOV   [__r1],A
    0543: 50 02    MOV   A,0x2
    0545: 3F 14    MVI   [__r1],A
(0056) 			}
    0547: 80 40    JMP   0x0588
(0057) 			else
(0058) 				gps->parse_status = IDLE;
    0549: 52 FB    MOV   A,[X-5]
    054B: 91 FC    CALL  <created procedures>
(0059) 			break;
    054D: 80 3A    JMP   0x0588
(0060) 		
(0061) 		case SFIX:
(0062) 			if ((gps->idx<FIX_POSITION) && (c == FIX_POSITION_MARK))
    054F: 92 01    CALL  0x0752
    0551: 39 05    CMP   A,0x5
    0553: D0 16    JNC   0x056A
    0555: 3D FC 2C CMP   [X-4],0x2C
    0558: B0 11    JNZ   0x056A
(0063) 				gps->idx++;
    055A: 52 FB    MOV   A,[X-5]
    055C: 01 02    ADD   A,0x2
    055E: 53 14    MOV   [__r1],A
    0560: 52 FA    MOV   A,[X-6]
    0562: 09 00    ADC   A,0x0
    0564: 53 15    MOV   [__r0],A
    0566: 92 0D    CALL  0x0775
    0568: 80 1F    JMP   0x0588
(0064) 			else if (gps->idx==FIX_POSITION) {
    056A: 91 E6    CALL  0x0752
    056C: 39 05    CMP   A,0x5
    056E: B0 19    JNZ   0x0588
(0065) 				gps->parse_status = IDLE;
    0570: 52 FB    MOV   A,[X-5]
    0572: 91 D5    CALL  <created procedures>
(0066) 				gps->fix_status = c - '0';
    0574: 52 FC    MOV   A,[X-4]
    0576: 11 30    SUB   A,0x30
    0578: 53 15    MOV   [__r0],A
    057A: 52 FB    MOV   A,[X-5]
    057C: 53 12    MOV   [__r3],A
    057E: 51 15    MOV   A,[__r0]
    0580: 3F 12    MVI   [__r3],A
(0067) 			}
(0068) 			break;
    0582: 80 05    JMP   0x0588
(0069) 
(0070) 		default :
(0071) 			gps->parse_status = IDLE;
    0584: 52 FB    MOV   A,[X-5]
    0586: 91 C1    CALL  <created procedures>
(0072) 			break;
    0588: 38 FE    ADD   SP,0xFE
    058A: 20       POP   X
    058B: 7F       RET   
(0073) 	}
(0074) }
(0075) 
(0076) void RX8_1_IRQ(void )
(0077) {
(0078) 	static BYTE _bData;
(0079) 	static BYTE _bStatus;
(0080) 	
(0081) 	_bStatus = RX8_1_bReadRxStatus();
_RX8_1_IRQ:
    058C: 10       PUSH  X
    058D: 7C 04 97 LCALL _RX8_1_bReadRxStatus|bRX8_1_ReadRxStatus|_bRX8_1_ReadRxStatus
    0590: 20       POP   X
    0591: 53 18    MOV   [0x18],A
(0082) 	
(0083) 	if ((_bStatus & RX8_1_RX_COMPLETE) && !(_bStatus & RX8_1_RX_ERROR))
    0593: 47 18 08 TST   [0x18],0x8
    0596: A0 48    JZ    0x05DF
    0598: 47 18 E0 TST   [0x18],0xE0
    059B: B0 43    JNZ   0x05DF
(0084) 	{
(0085) 		_bData = RX8_1_bReadRxData();
    059D: 10       PUSH  X
    059E: 7C 04 94 LCALL bRX8_1_ReadRxData|_RX8_1_bReadRxData|RX8_1_bReadRxData|_RX8_1_Stop|_bRX8_1_ReadRxData
    05A1: 20       POP   X
    05A2: 53 17    MOV   [0x17],A
(0086) 		
(0087) 		parse(_bData, &gps1);
    05A4: 50 00    MOV   A,0x0
    05A6: 08       PUSH  A
    05A7: 50 01    MOV   A,0x1
    05A9: 08       PUSH  A
    05AA: 51 17    MOV   A,[0x17]
    05AC: 08       PUSH  A
    05AD: 9F 0A    CALL  LED_FIX_Invert|LED_FIX_GetState|__UserModules_end|_parse|__text_start|_parse
    05AF: 38 FD    ADD   SP,0xFD
(0088) 		
(0089) 		if (gps1.fix_status >= gps2.fix_status)	// Higher priority
    05B1: 51 01    MOV   A,[gps1|_bStatus]
    05B3: 3A 04    CMP   A,[gps2]
    05B5: C0 11    JC    0x05C7
(0090) 			enqueue(&queue, _bData);
    05B7: 51 17    MOV   A,[0x17]
    05B9: 08       PUSH  A
    05BA: 50 00    MOV   A,0x0
    05BC: 08       PUSH  A
    05BD: 50 1B    MOV   A,0x1B
    05BF: 08       PUSH  A
    05C0: 7C 07 02 LCALL _enqueue
    05C3: 38 FD    ADD   SP,0xFD
    05C5: 80 19    JMP   0x05DF
(0091) 		else if ((gps1.fix_status == NO_FIX) && (gps2.fix_status == NO_FIX))	// Out GPS1 data if both GPSx are NOT FIXED
    05C7: 3C 01 00 CMP   [gps1|_bStatus],0x0
    05CA: B0 14    JNZ   0x05DF
    05CC: 3C 04 00 CMP   [gps2],0x0
    05CF: B0 0F    JNZ   0x05DF
(0092) 			enqueue(&queue, _bData);			
    05D1: 51 17    MOV   A,[0x17]
    05D3: 08       PUSH  A
    05D4: 50 00    MOV   A,0x0
    05D6: 08       PUSH  A
    05D7: 50 1B    MOV   A,0x1B
    05D9: 08       PUSH  A
    05DA: 7C 07 02 LCALL _enqueue
    05DD: 38 FD    ADD   SP,0xFD
(0093) 	}
    05DF: 7F       RET   
(0094) }
(0095) 
(0096) void RX8_2_IRQ(void )
(0097) {
(0098) 	static BYTE _bData;
(0099) 	static BYTE _bStatus;
(0100) 	
(0101) 	_bStatus = RX8_2_bReadRxStatus();
_RX8_2_IRQ:
    05E0: 10       PUSH  X
    05E1: 7C 04 20 LCALL _bRX8_2_ReadRxStatus|_RX8_2_bReadRxStatus|bRX8_2_ReadRxStatus|RX8_2_bReadRxStatus
    05E4: 20       POP   X
    05E5: 53 1A    MOV   [0x1A],A
(0102) 	
(0103) 	if ((_bStatus & RX8_2_RX_COMPLETE) && !(_bStatus & RX8_2_RX_ERROR))
    05E7: 47 1A 08 TST   [0x1A],0x8
    05EA: A0 2E    JZ    0x0619
    05EC: 47 1A E0 TST   [0x1A],0xE0
    05EF: B0 29    JNZ   0x0619
(0104) 	{
(0105) 		_bData = RX8_2_bReadRxData();
    05F1: 10       PUSH  X
    05F2: 7C 04 1D LCALL _RX8_2_Stop|RX8_2_bReadRxData|bRX8_2_ReadRxData|_bRX8_2_ReadRxData|_RX8_2_bReadRxData
    05F5: 20       POP   X
    05F6: 53 19    MOV   [0x19],A
(0106) 
(0107) 		parse(_bData, &gps2);
    05F8: 50 00    MOV   A,0x0
    05FA: 08       PUSH  A
    05FB: 50 04    MOV   A,0x4
    05FD: 08       PUSH  A
    05FE: 51 19    MOV   A,[0x19]
    0600: 08       PUSH  A
    0601: 9E B6    CALL  LED_FIX_Invert|LED_FIX_GetState|__UserModules_end|_parse|__text_start|_parse
    0603: 38 FD    ADD   SP,0xFD
(0108) 
(0109) 		if (gps2.fix_status > gps1.fix_status)
    0605: 51 01    MOV   A,[gps1|_bStatus]
    0607: 3A 04    CMP   A,[gps2]
    0609: D0 0F    JNC   0x0619
(0110) 			enqueue(&queue, _bData);
    060B: 51 19    MOV   A,[0x19]
    060D: 08       PUSH  A
    060E: 50 00    MOV   A,0x0
    0610: 08       PUSH  A
    0611: 50 1B    MOV   A,0x1B
    0613: 08       PUSH  A
    0614: 7C 07 02 LCALL _enqueue
    0617: 38 FD    ADD   SP,0xFD
(0111) 	}
    0619: 7F       RET   
(0112) }
(0113) 
(0114) void TX8_IRQ(void )
(0115) {
(0116) 	TX8_TX_Pending = TRUE;
_TX8_IRQ:
    061A: 55 00 01 MOV   [TX8_TX_Pending|_bData],0x1
    061D: 7F       RET   
(0117) }
(0118) 
(0119) void main(void)
(0120) {
_main:
  _bData               --> X+0
    061E: 10       PUSH  X
    061F: 4F       MOV   X,SP
    0620: 38 01    ADD   SP,0x1
(0121) 	BYTE _bData;
(0122) 	
(0123) 	initQueue(&queue);
    0622: 50 00    MOV   A,0x0
    0624: 08       PUSH  A
    0625: 50 1B    MOV   A,0x1B
    0627: 08       PUSH  A
    0628: 7C 06 9C LCALL _initQueue
    062B: 38 FE    ADD   SP,0xFE
(0124) 	
(0125) 	M8C_EnableGInt;
    062D: 71 01    OR    F,0x1
(0126) 	
(0127) 	TX8_EnableInt();
    062F: 10       PUSH  X
    0630: 7C 03 61 LCALL _TX8_EnableInt
(0128) 	TX8_Start(TX8_PARITY_NONE);
    0633: 50 00    MOV   A,0x0
    0635: 7C 03 65 LCALL _TX8_DisableInt|_TX8_Start|_TX8_SetTxIntMode|TX8_Start
(0129) 	
(0130) 	RX8_1_EnableInt();
    0638: 7C 04 8B LCALL _RX8_1_EnableInt
(0131) 	RX8_1_Start(RX8_1_PARITY_NONE);
    063B: 50 00    MOV   A,0x0
    063D: 7C 04 8F LCALL RX8_1_Start|_RX8_1_DisableInt|_RX8_1_Start
(0132) 
(0133) 	RX8_2_EnableInt();
    0640: 7C 04 14 LCALL _RX8_2_EnableInt
(0134) 	RX8_2_Start(RX8_2_PARITY_NONE);
    0643: 50 00    MOV   A,0x0
    0645: 7C 04 18 LCALL _RX8_2_DisableInt|RX8_2_Start|_RX8_2_Start
(0135) 	
(0136) 	TX8_CPutString("GPSSwitch\n\r");
    0648: 50 01    MOV   A,0x1
    064A: 08       PUSH  A
    064B: 50 50    MOV   A,0x50
    064D: 5C       MOV   X,A
    064E: 18       POP   A
    064F: 7C 03 A2 LCALL _TX8_CWrite|_TX8_CPutString|_TX8_Write|TX8_CPutString
(0137) 	
(0138) 	LED_FIX_Off();
    0652: 7C 04 A6 LCALL _LED_FIX_Start|LED_FIX_Stop|_LED_FIX_Off|_LED_FIX_Stop|LED_FIX_Start|LED_FIX_Off
    0655: 20       POP   X
    0656: 80 3E    JMP   0x0695
(0139) 	
(0140) 	while (TRUE)
(0141) 	{
(0142) 		M8C_ClearWDT;
    0658: 62 E3 00 MOV   REG[0xE3],0x0
(0143) 		
(0144) 		if ( TX8_TX_Pending )
    065B: 3C 00 00 CMP   [TX8_TX_Pending|_bData],0x0
    065E: A0 1E    JZ    0x067D
(0145) 		{			
(0146) 			if(dequeue(&queue, &_bData))
    0660: 51 15    MOV   A,[__r0]
    0662: 08       PUSH  A
    0663: 10       PUSH  X
    0664: 50 00    MOV   A,0x0
    0666: 08       PUSH  A
    0667: 50 1B    MOV   A,0x1B
    0669: 08       PUSH  A
    066A: 7C 06 B0 LCALL _dequeue
    066D: 38 FC    ADD   SP,0xFC
    066F: 39 00    CMP   A,0x0
    0671: A0 0B    JZ    0x067D
(0147) 			{
(0148) 				TX8_TX_Pending = FALSE;
    0673: 55 00 00 MOV   [TX8_TX_Pending|_bData],0x0
(0149) 				TX8_SendData(_bData);
    0676: 10       PUSH  X
    0677: 52 00    MOV   A,[X+0]
    0679: 7C 03 6A LCALL _TX8_Stop|TX8_SendData|_TX8_SendData
    067C: 20       POP   X
(0150) 			}
(0151) 		}
(0152) 		
(0153) 		if ((gps1.fix_status > NO_FIX) || (gps2.fix_status > NO_FIX))
    067D: 50 00    MOV   A,0x0
    067F: 3A 01    CMP   A,[gps1|_bStatus]
    0681: C0 07    JC    0x0689
    0683: 50 00    MOV   A,0x0
    0685: 3A 04    CMP   A,[gps2]
    0687: D0 08    JNC   0x0690
(0154) 			LED_FIX_On();
    0689: 10       PUSH  X
    068A: 7C 04 A2 LCALL _LED_FIX_On|_RX8_1_cReadChar|LED_FIX_On|_RX8_1_iReadChar
    068D: 20       POP   X
    068E: 80 06    JMP   0x0695
(0155) 		else 
(0156) 			LED_FIX_Off();
    0690: 10       PUSH  X
    0691: 7C 04 A6 LCALL _LED_FIX_Start|LED_FIX_Stop|_LED_FIX_Off|_LED_FIX_Stop|LED_FIX_Start|LED_FIX_Off
    0694: 20       POP   X
(0157) 	}
    0695: 8F C2    JMP   0x0658
(0158) }
FILE: C:\Users\MAB0B~1.SAN\Desktop\GPSMux\GPSSWI~1\GPSSWI~1\queue.c
(0001) #include "queue.h"
(0002) 
(0003) void initQueue(Queue* q)
(0004) {
_initQueue:
  q                    --> X-5
    069C: 10       PUSH  X
    069D: 4F       MOV   X,SP
(0005) 	q->count = 0;
    069E: 52 FC    MOV   A,[X-4]
    06A0: 53 14    MOV   [__r1],A
    06A2: 50 00    MOV   A,0x0
    06A4: 3F 14    MVI   [__r1],A
(0006) 	q->read_idx = 0;
    06A6: 52 FC    MOV   A,[X-4]
    06A8: 90 C2    CALL  0x076C
(0007) 	q->write_idx = 0;
    06AA: 52 FC    MOV   A,[X-4]
    06AC: 90 9B    CALL  <created procedures>
    06AE: 20       POP   X
    06AF: 7F       RET   
(0008) }
(0009) 
(0010) BOOL dequeue(Queue* q, BYTE* data) {
_dequeue:
  data                 --> X-7
  q                    --> X-5
    06B0: 10       PUSH  X
    06B1: 4F       MOV   X,SP
(0011) 	if (q->count<=0)
    06B2: 52 FC    MOV   A,[X-4]
    06B4: 53 14    MOV   [__r1],A
    06B6: 3E 14    MVI   A,[__r1]
    06B8: 53 15    MOV   [__r0],A
    06BA: 50 00    MOV   A,0x0
    06BC: 3A 15    CMP   A,[__r0]
    06BE: C0 05    JC    0x06C4
(0012) 		return FALSE;
    06C0: 50 00    MOV   A,0x0
    06C2: 80 3D    JMP   0x0700
(0013) 
(0014) 	*data = q->queue[q->read_idx];
    06C4: 52 FC    MOV   A,[X-4]
    06C6: 01 03    ADD   A,0x3
    06C8: 53 14    MOV   [__r1],A
    06CA: 52 FC    MOV   A,[X-4]
    06CC: 01 02    ADD   A,0x2
    06CE: 90 AE    CALL  0x077E
    06D0: 3E 14    MVI   A,[__r1]
    06D2: 53 15    MOV   [__r0],A
    06D4: 52 FA    MOV   A,[X-6]
    06D6: 53 12    MOV   [__r3],A
    06D8: 51 15    MOV   A,[__r0]
    06DA: 3F 12    MVI   [__r3],A
(0015) 	
(0016) 	q->read_idx++;
    06DC: 52 FC    MOV   A,[X-4]
    06DE: 01 02    ADD   A,0x2
    06E0: 90 79    CALL  0x075B
    06E2: 11 01    SUB   A,0x1
    06E4: 53 15    MOV   [__r0],A
    06E6: 52 FC    MOV   A,[X-4]
    06E8: 53 12    MOV   [__r3],A
    06EA: 51 15    MOV   A,[__r0]
    06EC: 3F 12    MVI   [__r3],A
(0017) 	
(0018) 	q->count--;
(0019) 	
(0020) 	if (q->read_idx >= QUEUE_DEPTH)
    06EE: 52 FC    MOV   A,[X-4]
    06F0: 01 02    ADD   A,0x2
    06F2: 53 14    MOV   [__r1],A
    06F4: 3E 14    MVI   A,[__r1]
    06F6: 39 40    CMP   A,0x40
    06F8: C0 05    JC    0x06FE
(0021) 		q->read_idx = 0;
    06FA: 52 FC    MOV   A,[X-4]
    06FC: 90 6E    CALL  0x076C
(0022) 	
(0023) 	return TRUE;
    06FE: 50 01    MOV   A,0x1
    0700: 20       POP   X
    0701: 7F       RET   
(0024) }
(0025) 
(0026) void enqueue(Queue* q, BYTE bData) {
_enqueue:
  bData                --> X-6
  q                    --> X-5
    0702: 10       PUSH  X
    0703: 4F       MOV   X,SP
(0027) 	if (q->count>QUEUE_DEPTH)
    0704: 52 FC    MOV   A,[X-4]
    0706: 53 14    MOV   [__r1],A
    0708: 3E 14    MVI   A,[__r1]
    070A: 53 15    MOV   [__r0],A
    070C: 50 40    MOV   A,0x40
    070E: 3A 15    CMP   A,[__r0]
    0710: D0 03    JNC   0x0714
(0028) 		return;	// TODO: manage overrun ?
    0712: 80 33    JMP   0x0746
(0029) 	
(0030) 	q->queue[q->write_idx] = bData;
    0714: 52 FC    MOV   A,[X-4]
    0716: 01 03    ADD   A,0x3
    0718: 53 14    MOV   [__r1],A
    071A: 52 FC    MOV   A,[X-4]
    071C: 01 01    ADD   A,0x1
    071E: 90 5E    CALL  0x077E
    0720: 52 FA    MOV   A,[X-6]
    0722: 3F 14    MVI   [__r1],A
(0031) 	
(0032) 	q->write_idx++;
    0724: 52 FC    MOV   A,[X-4]
    0726: 01 01    ADD   A,0x1
    0728: 90 31    CALL  0x075B
    072A: 01 01    ADD   A,0x1
    072C: 53 15    MOV   [__r0],A
    072E: 52 FC    MOV   A,[X-4]
    0730: 53 12    MOV   [__r3],A
    0732: 51 15    MOV   A,[__r0]
    0734: 3F 12    MVI   [__r3],A
(0033) 	
(0034) 	q->count++;
(0035) 	
(0036) 	if (q->write_idx >= QUEUE_DEPTH)
    0736: 52 FC    MOV   A,[X-4]
    0738: 01 01    ADD   A,0x1
    073A: 53 14    MOV   [__r1],A
    073C: 3E 14    MVI   A,[__r1]
    073E: 39 40    CMP   A,0x40
    0740: C0 05    JC    0x0746
(0037) 		q->write_idx = 0;
    0742: 52 FC    MOV   A,[X-4]
    0744: 90 03    CALL  <created procedures>
    0746: 20       POP   X
    0747: 7F       RET   
